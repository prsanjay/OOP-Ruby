<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<title>Struct</title>
	<link rel="stylesheet" href="includes/styles.css" type="text/css" media="all">
</head>
<body>
<div id="header">
	<h1>Programming Ruby</h1>
	<h2>The Pragmatic Programmer's Guide</h2>
</div><div id="menutop" class="menu">
	
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div><script type="text/javascript">
	top.frames.toc && top.frames.toc.SyncChanges && top.frames.toc.SyncChanges(null,'ref_c_struct',location.hash);
	top.document.title=document.title+' @ Programming Ruby';
</script>


<h1 class="class" id="Struct">class <strong>Struct</strong> &lt; Object</h1>

<p><strong>Subclasses:</strong> Struct::Tms</p>

<p>A <code class="class">Struct</code> is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class.</p>

<p>The <code class="class">Struct</code> class is a generator of specific classes, each one of which is defined to hold a set of variables and their accessors. In these examples, we'll call the generated class &ldquo;<i class="obj">Customer</i>Class,&rdquo; and we'll show an example instance of that class as &ldquo;<i class="obj">Customer</i>Inst.&rdquo;</p>

<p>In the descriptions that follow, the parameter <i class="obj">aSymbol</i> refers to a symbol, which is either a   quoted string or a <code class="class">Symbol</code> (such as <code>:name</code>).</p>

<h2 id="mixins">mixins</h2>
<dl>
	<dt><code class="module"><a href="ref_m_enumerable.html#Enumerable">Enumerable</a></code></dt>
	<dd><code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.collect">collect</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.detect">detect</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.each_with_index">each_with_index</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.entries">entries</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.find">find</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.find_all">find_all</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.grep">grep</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.include">include?</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.map">map</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.max">max</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.member">member?</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.min">min</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.reject">reject</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.select">select</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.sort">sort</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.to_a">to_a</a></code></dd>
</dl>

<h2 class="refsubsection" id="classmethods">class methods</h2>
<dl class="methodlist">
	<dt id="Struct.new">new</dt>
		<dd class="callseq">Struct.new( [<i class="obj">aString</i>] <i>[</i>, <i class="obj">aSym</i><i>]+</i> )  &rarr; <i class="obj">Customer</i>Class</dd>
		<dd class="desc"><p>Creates a new class, named by <i class="obj">aString</i>, containing accessor methods for the given symbols. If the name <i class="obj">aString</i> is omitted, an anonymous structure class will be created. Otherwise, the name of this struct will appear as a constant in class <code class="class">Struct</code>, so it must be unique for all <code class="class">Struct</code>s in the system and should start with a capital letter.</p>
			<p><code class="class_class_method"><a href="ref_c_struct.html#Struct.new"><span class="class">Struct</span>.<span class="method">new</span></a></code> returns a new <code class="class">Class</code> object, which can then be used to create specific instances of the new structure. The remaining methods listed below (class and instance) are defined for this generated class. See the description that follows for an example.</p>
		</dd>

	<dt id="Struct.new">new</dt>
		<dd class="callseq"><i class="obj">Customer</i>Class.new( <i>[</i><i class="obj">anObject</i><i>]+</i> )  &rarr; <i class="obj">Customer</i>Inst</dd>
		<dd class="desc">Creates a new instance.  The number of actual parameters must be less than or equal to the number of attributes defined for this class; unset parameters default to <code>nil</code>.  Passing too many parameters will raise an <code class="exception">ArgumentError</code>.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joe.name <span class="output"><span class="outputmark">&rarr;</span> "Joe Smith"</span>
joe.zip <span class="output"><span class="outputmark">&rarr;</span> 12345</span></code></div>

		</dd>

	<dt id="Struct.members">members</dt>
		<dd class="callseq"><i class="obj">Customer</i>Class.members  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc">Returns an array of strings representing the names of the instance variables.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
Customer.members <span class="output"><span class="outputmark">&rarr;</span> ["name", "address", "zip"]</span></code></div>

		</dd>
</dl>

<h2 class="refsubsection" id="instancemethods">instance methods</h2>
<dl class="methodlist">
	<dt id="Struct._eq_eq">==</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst == <i class="obj">anOtherStruct</i>  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="desc">Equality&mdash;Returns <code class="const">true</code> if <i class="obj">anOtherStruct</i> is equal to this one: they must be of the same class as generated by <code class="class_class_method"><a href="ref_c_struct.html#Struct.new"><span class="class">Struct</span>.<span class="method">new</span></a></code>, and the values of all instance variables must be equal (according to <code class="class_instance_method"><a href="ref_c_object.html#Object._eq_eq"><span class="class">Object</span>#<span class="method">==</span></a></code>).

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe   = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joejr = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
jane  = Customer.new( "Jane Doe", "456 Elm, Anytown NC", 12345 )
joe == joejr <span class="output"><span class="outputmark">&rarr;</span> true</span>
joe == jane <span class="output"><span class="outputmark">&rarr;</span> false</span></code></div>

		</dd>

	<dt id="Struct._ob_cb">[ ]</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst[ <i class="obj">aSymbol</i> ]  &rarr; <i class="obj">anObject</i></dd>
		<dd class="callseq"><i class="obj">Customer</i>Inst[ <i class="obj">anInteger</i> ]  &rarr; <i class="obj">anObject</i></dd>
		<dd class="desc">Attribute Reference&mdash;Returns the value of the instance variable named by <i class="obj">aSymbol</i>, or indexed (0..length-1) by <i class="obj">anInteger</i>.  Will raise <code class="exception">NameError</code> if the named variable does not exist, or <code class="exception">IndexError</code> if the index is out of range.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )

joe["name"] <span class="output"><span class="outputmark">&rarr;</span> "Joe Smith"</span>
joe[:name] <span class="output"><span class="outputmark">&rarr;</span> "Joe Smith"</span>
joe[0] <span class="output"><span class="outputmark">&rarr;</span> "Joe Smith"</span></code></div>

		</dd>

	<dt id="Struct._ob_cb_eq">[ ]=</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst[ <i class="obj">aSymbol</i> ] = <i class="obj">anObject</i>  &rarr; <i class="obj">anObject</i></dd>
		<dd class="callseq"><i class="obj">Customer</i>Inst[ <i class="obj">anInteger</i> ] = <i class="obj">anObject</i>  &rarr; <i class="obj">anObject</i></dd>
		<dd class="desc">Attribute Assignment&mdash;Assigns to the instance variable named by <i class="obj">aSymbol</i> or <i class="obj">anInteger</i> the value <i class="obj">anObject</i> and returns it.  Will raise a <code class="exception">NameError</code> if the named variable does not exist, or an <code class="exception">IndexError</code> if the index is out of range.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )

joe["name"] = "Luke"
joe[:zip]   = "90210"

joe.name <span class="output"><span class="outputmark">&rarr;</span> "Luke"</span>
joe.zip <span class="output"><span class="outputmark">&rarr;</span> "90210"</span></code></div>

		</dd>

	<dt id="Struct.each">each</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.each {| anObject | block }  &rarr; <i class="obj">Customer</i>Inst</dd>
		<dd class="desc">Calls <i class="obj">block</i> once for each instance variable, passing the value as a parameter.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joe.each {|x| puts(x) }</code></div>
<p class="produces"><em>produces:</em></p>
<div><code class="block">Joe Smith
123 Maple, Anytown NC
12345</code></div>

		</dd>

	<dt id="Struct.length">length</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.length  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Returns the number of instance variables.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joe.length <span class="output"><span class="outputmark">&rarr;</span> 3</span></code></div>

		</dd>

	<dt id="Struct.members">members</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.members  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc">Returns an array of strings representing the names of the instance variables.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joe.members <span class="output"><span class="outputmark">&rarr;</span> ["name", "address", "zip"]</span></code></div>

		</dd>

	<dt id="Struct.size">size</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.size  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_struct.html#Struct.length"><span class="class">Struct</span>#<span class="method">length</span></a></code>.

		</dd>

	<dt id="Struct.to_a">to_a</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.to_a  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc">Returns the values for this instance as an array.

<div><code class="block">Customer = Struct.new( "Customer", :name, :address, :zip )
joe = Customer.new( "Joe Smith", "123 Maple, Anytown NC", 12345 )
joe.to_a[1] <span class="output"><span class="outputmark">&rarr;</span> "123 Maple, Anytown NC"</span></code></div>

		</dd>

	<dt id="Struct.values">values</dt>
		<dd class="callseq"><i class="obj">Customer</i>Inst.values  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc">Synonym for <code class="method">to_a</code>.</dd>
</dl>

<div id="menubot" class="menu">
	
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div>

<div id="copyright">
	<p>Extracted from the book "Programming Ruby -  The Pragmatic Programmer's Guide"</p>
	<p>Copyright &copy; 2001 by Addison Wesley Longman, Inc. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at <a href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>).</p>
	<p>Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder.</p>
	<p>Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.</p>
</div>

<a href="ref_c_struct.html" target="_top" id="expand" title="Show this content in its own window" onclick="this.href=window.location.href"><img src="includes/expand.png" alt="Show this content in its own window" width="15" height="15"></a>
<script type="text/javascript">
	if (top==self && document.getElementById){
		ex = document.getElementById('expand');
		img = ex.getElementsByTagName('img')[0];
		ex.title=img.alt="Show this content alongside the Table of Contents";
		ex.onclick=function(){ return true }
		ex.href="frameset.html?content="+escape(self.location.href);
		img.src="includes/collapse.png";
	}
</script>
</body>
</html>
