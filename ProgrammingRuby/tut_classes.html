<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<title>Classes, Objects, and Variables</title>
	<link rel="stylesheet" href="includes/styles.css" type="text/css" media="all">
</head>
<body>
<div id="header">
	<h1>Programming Ruby</h1>
	<h2>The Pragmatic Programmer's Guide</h2>
</div><div id="menutop" class="menu">
	<a href="intro.html" class="prev">&lt; Previous</a><a href="tut_containers.html" class="next">Next &gt;</a>
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div><script type="text/javascript">
	top.frames.toc && top.frames.toc.SyncChanges && top.frames.toc.SyncChanges(null,'tut_classes',location.hash);
	top.document.title=document.title+' @ Programming Ruby';
</script>

<h1 id="classesobjectsandvariables">Classes, Objects, and Variables</h1>
<p>From the examples we've shown so far, you might be wondering about our earlier assertion that Ruby is an object-oriented language.  Well, this chapter is where we justify that claim. We're going to be looking at how you create classes and objects in Ruby, and at some of the ways in which Ruby is more powerful than most object-oriented languages. Along the way, we'll be implementing part of our next billion-dollar product, the Internet Enabled Jazz and Blue Grass jukebox.</p>
<p>After months of work, our highly paid Research and Development folks have determined that our jukebox needs <em>songs</em>. So it seems like a good idea to start off by setting up a Ruby class that represents things that are songs.  We know that a real song has a name, an artist, and a duration, so we'll want to make sure that the song objects in our program do, too.</p>
<p>We'll start off by creating a basic class <code class="class">Song</code>, which contains just a single method, <code class="method">initialize</code>. <span class="footnote">(As we mentioned in &ldquo;<a href="intro.html#somebasicruby">Some Basic Ruby</a>&rdquo;, class names start with an uppercase letter, while method names start with a lowercase letter.)</span></p>

<div><code class="block">class Song
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
  end
end</code></div>
<p><code class="method">initialize</code> is a special method in Ruby programs. When you call <code class="class_class_method"><span class="class">Song</span>.<span class="method">new</span></code> to create a new <code class="class">Song</code> object, Ruby creates an uninitialized object and then calls that object's <code>initialize</code> method, passing in any parameters that were passed to <code class="method">new</code>. This gives you a chance to write code that sets up your object's state.</p>
<p>For class <code class="class">Song</code>, the <code class="method">initialize</code> method takes three parameters. These parameters act just like local variables within the method, so they follow the local variable naming convention of starting with a lowercase letter.</p>
<p>Each object represents its own song, so we need each of our <code class="class">Song</code> objects to carry around its own song name, artist, and duration.  This means we need to store these values as <em>instance variables</em> within the object. In Ruby, an instance variable is simply a name preceded by an &ldquo;at&rdquo; sign (&ldquo;@&rdquo;). In our example, the parameter <var>name</var> is assigned to the instance variable <var>@name</var>, <var>artist</var> is assigned to <var>@artist</var>, and <var>duration</var> (the length of the song in seconds) is assigned to <var>@duration</var>.</p>
<p>Let's test our spiffy new class.</p>

<div><code class="block">aSong = Song.new("Bicylops", "Fleck", 260)
aSong.inspect <span class="output" style="width:48em"><span class="outputmark">&rarr;</span> "#&lt;Song:0x401b4924 @duration=260, @artist=\"Fleck\", @name=\"Bicylops\"&gt;"</span></code></div>


<p>Well, it seems to work. By default, the <code class="method">inspect</code> message, which can be sent to any object, dumps out the object's id and instance variables. It looks as though we have them set up correctly.</p>
<p>Our experience tells us that during development we'll be printing out the contents of a <code class="class">Song</code> object many times, and <code class="method">inspect</code>'s default formatting leaves something to be desired. Fortunately, Ruby has a standard message, <code class="method">to_s</code>, which it sends to any object it wants to render as a string. Let's try it on our song.</p>

<div><code class="block">aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s <span class="output"><span class="outputmark">&rarr;</span> "#&lt;Song:0x401b499c&gt;"</span></code></div>

<p>That wasn't too useful&mdash;it just reported the object id. So, let's override <code class="method">to_s</code> in our class. As we do this, we should also take a moment to talk about how we're showing the class definitions in this book.</p>
<p>In Ruby, classes are never closed: you can always add methods to an existing class. This applies to the classes you write as well as the standard, built-in classes. All you have to do is open up a class definition for an existing class, and the new contents you specify will be added to whatever's there.</p>
<p>This is great for our purposes. As we go through this chapter, adding features to our classes, we'll show just the class definitions for the new methods; the old ones will still be there. It saves us having to repeat redundant stuff in each example. Obviously, though, if you were creating this code from scratch, you'd probably just throw all the methods into a single class definition.</p>
<p>Enough detail! Let's get back to adding a <code class="method">to_s</code> method to our <code class="class">Song</code> class.</p>

<div><code class="block" id="songtosdef">class Song
  def to_s
    "Song: #{@name}--#{@artist} (#{@duration})"
  end
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.to_s <span class="output"><span class="outputmark">&rarr;</span> "Song: Bicylops--Fleck (260)"</span></code></div>

<p>Excellent, we're making progress.  However, we've slipped in something subtle. We said that Ruby supports <code class="method">to_s</code> for all objects, but we didn't say how. The answer has to do with inheritance, subclassing, and how Ruby determines what method to run when you send a message to an object. This is a subject for a new section, so....</p>

<h2 id="inheritanceandmessages">Inheritance and Messages</h2>
<p>Inheritance allows you to create a class that is a refinement or specialization of another class. For example, our jukebox has the concept of songs, which we encapsulate in class <code class="class">Song</code>. Then marketing comes along and tells us that we need to provide karaoke support. A karaoke song is just like any other (there's no vocal on it, but that doesn't concern us). However, it also has an associated set of lyrics, along with timing information. When our jukebox plays a karaoke song, the lyrics should flow across the screen on the front of the jukebox in time with the music.</p>
<p>An approach to this problem is to define a new class, <code class="class">KaraokeSong</code>, which is just like <code class="class">Song</code>, but with a lyric track.</p>

<div><code class="block">class KaraokeSong &lt; Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration)
    @lyrics = lyrics
  end
end</code></div>
<p>The &ldquo;<code>&lt; Song</code>&rdquo; on the class definition line tells Ruby that a <code class="class">KaraokeSong</code> is a <em>subclass</em> of <code class="class">Song</code>. (Not surprisingly, this means that <code class="class">Song</code> is a <em>superclass</em> of <code class="class">KaraokeSong</code>. People also talk about parent-child relationships, so <code class="class">KaraokeSong</code>'s parent would be <code class="class">Song</code>.) For now, don't worry too much about the <code class="method">initialize</code> method; we'll talk about that <code>super</code> call later.</p>
<p>Let's create a <code class="class">KaraokeSong</code> and check that our code worked. (In the final system, the lyrics will be held in an object that includes the text and timing information. To test out our class, though, we'll just use a string. This is another benefit of untyped languages&mdash;we don't have to define everything before we start running code.</p>

<div><code class="block">aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s <span class="output"><span class="outputmark">&rarr;</span> "Song: My Way--Sinatra (225)"</span></code></div>


<p>Well, it ran, but why doesn't the <code class="method">to_s</code> method show the lyric?</p>
<p>The answer has to do with the way Ruby determines which method should be called when you send a message to an object. When Ruby compiles the method invocation <code>aSong.to_s</code>, it doesn't actually know where to find the method <code class="method">to_s</code>. Instead, it defers the decision until the program is run. At that time, it looks at the class of <code>aSong</code>. If that class implements a method with the same name as the message, that method is run. Otherwise, Ruby looks for a method in the parent class, and then in the grandparent, and so on up the ancestor chain. If it runs out of ancestors without finding the appropriate method, it takes a special action that normally results in an error being raised. <span class="footnote">(In fact, you can intercept this error, which allows you to fake out methods at runtime. This is described under   <code class="class_instance_method"><a href="ref_c_object.html#Object.method_missing"><span class="class">Object</span>#<span class="method">method_missing</span></a></code>.)</span></p>
<p>So, back to our example. We sent the message <code class="method">to_s</code> to <code>aSong</code>, an object of class <code class="class">KaraokeSong</code>. Ruby looks in <code class="class">KaraokeSong</code> for a method called <code class="method">to_s</code>, but doesn't find it. The interpreter then looks in <code class="class">KaraokeSong</code>'s parent, class <code class="class">Song</code>, and there it finds the <code class="method">to_s</code> method that we <a href="tut_classes.html#songtosdef">defined earlier</a>. That's why it prints out the song details but not the lyrics&mdash;class <code class="class">Song</code> doesn't know anything about lyrics.</p>
<p>Let's fix this by implementing <code class="class_instance_method"><span class="class">KaraokeSong</span>#<span class="method">to_s</span></code>. There are a number of ways to do this. Let's start with a bad way. We'll copy the <code class="method">to_s</code> method from <code class="class">Song</code> and add on the lyric.</p>

<div><code class="block">class KaraokeSong
  # ...
  def to_s
    "KS: #{@name}--#{@artist} (#{@duration}) [#{@lyrics}]"
  end
end
aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s <span class="output" style="width:35em"><span class="outputmark">&rarr;</span> "KS: My Way--Sinatra (225) [And now, the...]"</span></code></div>


<p>We're correctly displaying the value of the <var>@lyrics</var> instance variable. To do this, the subclass directly accesses the instance variables of its ancestors. So why is this a bad way to implement <code class="method">to_s</code>?</p>
<p>The answer has to do with good programming style (and something called <em>decoupling</em>). By poking around in our parent's internal state, we're tying ourselves tightly to its implementation. Say we decided to change <code class="class">Song</code> to store the duration in milliseconds. Suddenly, <code class="class">KaraokeSong</code> would start reporting ridiculous values. The idea of a karaoke version of &ldquo;My Way&rdquo; that lasts for 3750 minutes is just too frightening to consider.</p>
<p>We get around this problem by having each class handle its own internal state. When <code class="class_instance_method"><span class="class">KaraokeSong</span>#<span class="method">to_s</span></code> is called, we'll have it call its parent's <code class="method">to_s</code> method to get the song details. It will then append to this the lyric information and return the result. The trick here is the Ruby keyword &ldquo;<code class="keyword">super</code>&rdquo;. When you invoke <code class="keyword">super</code> with no arguments, Ruby sends a message to the current object's parent, asking it to invoke a method of the same name as the current method, and passing it the parameters that were passed to the current method. Now we can implement our new and improved <code class="method">to_s</code>.</p>

<div><code class="block">class KaraokeSong &lt; Song
  # Format ourselves as a string by appending
  # our lyrics to our parent's #to_s value.
  def to_s
    super + " [#{@lyrics}]"
  end
end
aSong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
aSong.to_s <span class="output" style="width:35em"><span class="outputmark">&rarr;</span> "Song: My Way--Sinatra (225) [And now, the...]"</span></code></div>


<p>We explicitly told Ruby that <code>KaraokeSong</code> was a subclass of <code class="class">Song</code>, but we didn't specify a parent class for <code class="class">Song</code> itself. If you don't specify a parent when defining a class, Ruby supplies class <code class="class">Object</code> as a default. This means that all objects have <code class="class">Object</code> as an ancestor, and that <code class="class">Object</code>'s instance methods are available to every object in Ruby. Back at the start of this chapter we said that <code class="method">to_s</code> is available to all objects. Now we know why; <code class="method">to_s</code> is one of more than 35 instance methods in class <code class="class">Object</code>. The complete list can be found in the reference for <code class="class"><a href="ref_c_object.html">Object</a></code>.</p>

<h3 id="inheritanceandmixins">Inheritance and Mixins</h3>
<p>Some object-oriented languages (notably C++) support multiple inheritance, where a class can have more than one immediate parent, inheriting functionality from each. Although powerful, this technique can be dangerous, as the inheritance hierarchy can become ambiguous.</p>
<p>Other languages, such as Java, support single inheritance. Here, a class can have only one immediate parent. Although cleaner (and easier to implement), single inheritance also has drawbacks&mdash;in the real world things often inherit attributes from multiple sources (a ball is both a <em>bouncing thing</em> and a <em>spherical thing</em>, for example).</p>
<p>Ruby offers an interesting and powerful compromise, giving you the simplicity of single inheritance and the power of multiple inheritance. A Ruby class can have only one direct parent, and so Ruby is a single-inheritance language. However, Ruby classes can include the functionality of any number of mixins (a mixin is like a partial class definition). This provides a controlled multiple-inheritance-like capability with none of the drawbacks. We'll explore mixins more in the section &ldquo;<a href="tut_modules.html#mixins">Mixins</a>&rdquo; in the chapter on modules.</p>
<p>So far in this chapter we've been looking at classes and their methods. Now it's time to move on to the objects, such as the instances of class <code class="class">Song</code>.</p>

<h2 id="objectsandattributes">Objects and Attributes</h2>
<p>The <code class="class">Song</code> objects we've created so far have an internal state (such as the song title and artist). That state is private to those objects&mdash;no other object can access an object's instance variables. In general, this is a Good Thing. It means that the object is solely responsible for maintaining its own consistency.</p>
<p>However, an object that is totally secretive is pretty useless&mdash;you can create it, but then you can't do anything with it. You'll normally define methods that let you access and manipulate the state of an object, allowing the outside world to interact with the object. These externally visible facets of an object are called its <em>attributes</em>.</p>
<p>For our <code class="class">Song</code> objects, the first thing we may need is the ability to find out the title and artist (so we can display them while the song is playing) and the duration (so we can display some kind of progress bar).</p>

<div><code class="block">class Song
  def name
    @name
  end
  def artist
    @artist
  end
  def duration
    @duration
  end
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist <span class="output"><span class="outputmark">&rarr;</span> "Fleck"</span>
aSong.name <span class="output"><span class="outputmark">&rarr;</span> "Bicylops"</span>
aSong.duration <span class="output"><span class="outputmark">&rarr;</span> 260</span></code></div>

<p>Here we've defined three accessor methods to return the values of the three instance attributes. Because this is such a common idiom, Ruby provides a convenient shortcut: <code class="method">attr_reader</code> creates these accessor methods for you.</p>

<div><code class="block">class Song
  attr_reader :name, :artist, :duration
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.artist <span class="output"><span class="outputmark">&rarr;</span> "Fleck"</span>
aSong.name <span class="output"><span class="outputmark">&rarr;</span> "Bicylops"</span>
aSong.duration <span class="output"><span class="outputmark">&rarr;</span> 260</span></code></div>


<p>This example has introduced something new. The construct <code>:artist</code> is an expression that returns a <code class="class">Symbol</code> object corresponding to <code>artist</code>. You can think of <code>:artist</code> as meaning the <em>name</em> of the variable <code>artist</code>, while plain <code>artist</code> is the <em>value</em> of the variable. In this example, we named the accessor methods <var>name</var>, <var>artist</var>, and <var>duration</var>.  The corresponding instance variables, <var>@name</var>, <var>@artist</var>, and <var>@duration</var>, will be created automatically.  These accessor methods are identical to the ones we wrote by hand earlier.</p>

<h3 id="writableattributes">Writable Attributes</h3>
<p>Sometimes you need to be able to set an attribute from outside the object. For example, let's assume that the duration that is initially associated with a song is an estimate (perhaps gathered from information on a CD or in the MP3 data). The first time we play the song, we get to find out how long it actually is, and we store this new value back in the <code class="class">Song</code> object.</p>
<p>In languages such as C++ and Java, you'd do this with <em>setter functions</em>.</p>

<div><code class="block">class JavaSong {                     // Java code
  private Duration myDuration;
  public void setDuration(Duration newDuration) {
    myDuration = newDuration;
  }
}
s = new Song(....)
s.setDuration(length)</code></div>
<p>In Ruby, the attributes of an object can be accessed as if they were any other variable. We've seen this above with phrases such as <code>aSong.name</code>. So, it seems natural to be able to assign to these variables when you want to set the value of an attribute. In keeping with the Principle of Least Surprise, that's just what you do in Ruby.</p>

<div><code class="block">class Song
  def duration=(newDuration)
    @duration = newDuration
  end
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration <span class="output"><span class="outputmark">&rarr;</span> 260</span>
aSong.duration = 257   # set attribute with updated value
aSong.duration <span class="output"><span class="outputmark">&rarr;</span> 257</span></code></div>

<p>The assignment &ldquo;<code>aSong.duration = 257</code>&rdquo; invokes the method <code class="method">duration=</code> in the <code>aSong</code> object, passing it <code>257</code> as an argument. In fact, defining a method name ending in an equals sign makes that name eligible to appear on the left-hand side of an assignment.</p>
<p>Again, Ruby provides a shortcut for creating these simple attribute setting methods.</p>

<div><code class="block">class Song
  attr_writer :duration
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.duration = 257</code></div>


<h3 id="virtualattributes">Virtual Attributes</h3>
<p>These attribute accessing methods do not have to be just simple wrappers around an object's instance variables. For example, you might want to access the duration in minutes and fractions of a minute, rather than in seconds as we've been doing.</p>

<div><code class="block">class Song
  def durationInMinutes
    @duration/60.0   # force floating point
  end
  def durationInMinutes=(value)
    @duration = (value*60).to_i
  end
end
aSong = Song.new("Bicylops", "Fleck", 260)
aSong.durationInMinutes <span class="output"><span class="outputmark">&rarr;</span> 4.333333333</span>
aSong.durationInMinutes = 4.2
aSong.duration <span class="output"><span class="outputmark">&rarr;</span> 252</span></code></div>


<p>Here we've used attribute methods to create a virtual instance variable. To the outside world, <code>durationInMinutes</code> seems to be an attribute like any other. Internally, though, there is no corresponding instance variable.</p>
<p>This is more than a curiosity. In his landmark book <em>Object-Oriented Software Construction</em>, Bertrand Meyer calls this the <em>Uniform Access Principle</em>. By hiding the difference between instance variables and calculated values, you are shielding the rest of the world from the implementation of your class. You're free to change how things work in the future without impacting the millions of lines of code that use your class. This is a big win.</p>

<h2 id="classvariablesandclassmethods">Class Variables and Class Methods</h2>
<p>So far, all the classes we've created have contained instance variables and instance methods: variables that are associated with a particular instance of the class, and methods that work on those variables.  Sometimes classes themselves need to have their own states. This is where class variables come in.</p>

<h3 id="classvariables">Class Variables</h3>
<p>A class variable is shared among all objects of a class, and it is also accessible to the class methods that we'll describe later. There is only one copy of a particular class variable for a given class. Class variable names start with two &ldquo;at&rdquo; signs, such as &ldquo;<code>@@count</code>&rdquo;. Unlike global and instance variables, class variables must be initialized before they are used.  Often this initialization is just a simple assignment in the body of the class definition.</p>
<p>For example, our jukebox may want to record how many times each particular song has been played. This count would probably be an instance variable of the <code class="class">Song</code> object. When a song is played, the value in the instance is incremented. But say we also want to know how many songs have been played in total. We could do this by searching for all the <code class="class">Song</code> objects and adding up their counts, or we could risk excommunication from the Church of Good Design and use a global variable. Instead, we'll use a class variable.</p>

<div><code class="block">class Song
  @@plays = 0
  def initialize(name, artist, duration)
    @name     = name
    @artist   = artist
    @duration = duration
    @plays    = 0
  end
  def play
    @plays += 1
    @@plays += 1
    "This song: #@plays plays. Total #@@plays plays."
  end
end</code></div>

<p>For debugging purposes, we've arranged for <code class="class_instance_method"><span class="class">Song</span>#<span class="method">play</span></code> to return a string containing the number of times this song has been played, along with the total number of plays for all songs. We can test this easily.</p>

<div><code class="block">s1 = Song.new("Song1", "Artist1", 234)  # test songs..
s2 = Song.new("Song2", "Artist2", 345)
s1.play <span class="output"><span class="outputmark">&rarr;</span> "This song: 1 plays. Total 1 plays."</span>
s2.play <span class="output"><span class="outputmark">&rarr;</span> "This song: 1 plays. Total 2 plays."</span>
s1.play <span class="output"><span class="outputmark">&rarr;</span> "This song: 2 plays. Total 3 plays."</span>
s1.play <span class="output"><span class="outputmark">&rarr;</span> "This song: 3 plays. Total 4 plays."</span></code></div>

<p>Class variables are private to a class and its instances. If you want to make them accessible to the outside world, you'll need to write an accessor method. This method could be either an instance method or, leading us neatly to the next section, a class method.</p>

<h3 id="classmethods">Class Methods</h3>
<p>Sometimes a class needs to provide methods that work without being tied to any particular object.</p>
<p>We've already come across one such method. The <code class="method">new</code> method creates a new <code class="class">Song</code> object but is not itself associated with a particular song.</p>

<div><code class="block">aSong = Song.new(....)</code></div>

<p>You'll find class methods sprinkled throughout the Ruby libraries. For example, objects of class <code class="class">File</code> represent open files in the underlying file system. However, class <code class="class">File</code> also provides several class methods for manipulating files that aren't open and therefore don't have a <code class="class">File</code> object. If you want to delete a file, you call the class method <code class="class_class_method"><a href="ref_c_file.html#File.delete"><span class="class">File</span>.<span class="method">delete</span></a></code>, passing in the name.</p>

<div><code class="block">File.delete("doomedFile")</code></div>

<p>Class methods are distinguished from instance methods by their definition. Class methods are defined by placing the class name and a period in front of the method name.</p>

<div><code class="block">class Example

  def instMeth              # instance method
  end

  def Example.classMeth     # class method
  end

end</code></div>

<p>Jukeboxes charge money for each song played, not by the minute. That makes short songs more profitable than long ones. We may want to prevent songs that take too long from being available on the SongList. We could define a class method in <code class="class">SongList</code> that checked to see if a particular song exceeded the limit. We'll set this limit using a class constant, which is simply a constant (remember constants? they start with an uppercase letter) that is initialized in the class body.</p>

<div><code class="block">class SongList
  MaxTime = 5*60           #  5 minutes

  def SongList.isTooLong(aSong)
    return aSong.duration &gt; MaxTime
  end
end
song1 = Song.new("Bicylops", "Fleck", 260)
SongList.isTooLong(song1) <span class="output"><span class="outputmark">&rarr;</span> false</span>
song2 = Song.new("The Calling", "Santana", 468)
SongList.isTooLong(song2) <span class="output"><span class="outputmark">&rarr;</span> true</span></code></div>




<h3 id="singletonsandotherconstructors">Singletons and Other Constructors</h3>
<p>Sometimes you want to override the default way in which Ruby creates objects.  As an example, let's look at our jukebox. Because we'll have many jukeboxes, spread all over the country, we want to make maintenance as easy as possible. Part of the requirement is to log everything that happens to a jukebox: the songs that are played, the money received, the strange fluids poured into it, and so on. Because we want to reserve the network bandwidth for music, we'll store these logfiles locally.  This means we'll need a class that handles logging. However, we want only one logging object per jukebox, and we want that object to be shared among all the other objects that use it.</p>
<p>Enter the Singleton pattern, documented in <em>Design   Patterns</em> . We'll arrange things so that the only way to create a logging object is to call <code class="class_class_method"><span class="class">Logger</span>.<span class="method">create</span></code>, and we'll ensure that only one logging object is ever created.</p>

<div><code class="block">class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end</code></div>

<p>By making <code class="class">Logger</code>'s method <code class="method">new</code> private, we prevent anyone from creating a logging object using the conventional constructor. Instead, we provide a class method, <code class="class_class_method"><span class="class">Logger</span>.<span class="method">create</span></code>. This uses the class variable <var>@@logger</var> to keep a reference to a single instance of the logger, returning that instance every time it is called. <span class="footnote">The implementation of singletons that we present here is not thread-safe; if multiple threads were running, it would be possible to create multiple logger objects. Rather than add thread safety ourselves, however, we'd probably use the <code class="module"><a href="lib_patterns.html#singleton">Singleton</a></code> mixin supplied with Ruby.</span> We can check this by looking at the object identifiers the method returns.</p>

<div><code class="block">Logger.create.id <span class="output"><span class="outputmark">&rarr;</span> 537766930</span>
Logger.create.id <span class="output"><span class="outputmark">&rarr;</span> 537766930</span></code></div>

<p>Using class methods as pseudo-constructors can also make life easier for users of your class. As a trivial example, let's look at a class <code class="class">Shape</code> that represents a regular polygon. Instances of <code class="class">Shape</code> are created by giving the constructor the required number of sides and the total perimeter.</p>

<div><code class="block">class Shape
  def initialize(numSides, perimeter)
    # ...
  end
end</code></div>

<p>However, a couple of years later, this class is used in a different application, where the programmers are used to creating shapes by name, and by specifying the length of the side, not the perimeter. Simply add some class methods to <code class="class">Shape</code>.</p>

<div><code class="block">class Shape
  def Shape.triangle(sideLength)
    Shape.new(3, sideLength*3)
  end
  def Shape.square(sideLength)
    Shape.new(4, sideLength*4)
  end
end</code></div>

<p>There are many interesting and powerful uses of class methods, but exploring them won't get our jukebox finished any sooner, so let's move on.</p>

<h2 id="accesscontrol">Access Control</h2>
<p>When designing a class interface, it's important to consider just how much access to your class you'll be exposing to the outside world. Allow too much access into your class, and you risk increasing the coupling in your application&mdash;users of your class will be tempted to rely on details of your class's implementation, rather than on its logical interface.  The good news is that the only way to change an object's state in Ruby is by calling one of its methods.  Control access to the methods and you've controlled access to the object. A good rule of thumb is never to expose methods that could leave an object in an invalid state.  Ruby gives us three levels of protection.</p>
<ul>
	<li><strong>Public methods</strong> can be called by anyone&mdash;there is no access control. Methods are public by default (except for <code class="method">initialize</code>, which is always private).</li>
	<li><strong>Protected methods</strong> can be invoked only by objects of the defining class and its subclasses. Access is kept within the family.</li>
	<li><strong>Private methods</strong> cannot be called with an explicit receiver. Because you cannot specify an object when using them, private methods can be called only in the defining class and by direct descendents within that same object.</li>
</ul>

<p>The difference between &ldquo;protected&rdquo; and &ldquo;private&rdquo; is fairly subtle, and is different in Ruby than in most common OO languages. If a method is protected, it may be called by <em>any</em> instance of the defining class or its subclasses. If a method is private, it may be called only within the context of the calling object&mdash;it is never possible to access another object's private methods directly, even if the object is of the same class as the caller.</p>
<p>Ruby differs from other OO languages in another important way. Access control is determined dynamically, as the program runs, not statically. You will get an access violation only when the code attempts to execute the restricted method.</p>

<h3 id="specifyingaccesscontrol">Specifying Access Control</h3>
<p>You specify access levels to methods within class or module definitions using one or more of the three functions <code class="keyword">public</code>, <code class="keyword">protected</code>, and <code class="keyword">private</code>. Each function can be used in two different ways.</p>
<p>If used with no arguments, the three functions set the default access control of subsequently defined methods. This is probably familiar behavior if you're a C++ or Java programmer, where you'd use keywords such as <code class="keyword">public</code> to achieve the same effect.</p>

<div><code class="block">class MyClass

    def method1    # default is 'public'
      #...
    end

  protected          # subsequent methods will be 'protected'

    def method2    # will be 'protected'
      #...
    end

  private            # subsequent methods will be 'private'

    def method3    # will be 'private'
      #...
    end

  public             # subsequent methods will be 'public'

    def method4    # and this will be 'public'
      #...
    end
end</code></div>

<p>Alternatively, you can set access levels of named methods by listing them as arguments to the access control functions.</p>

<div><code class="block">class MyClass

  def method1
  end

  # ... and so on

  public    :method1, :method4
  protected :method2
  private   :method3
end</code></div>

<p>A class's <code class="method">initialize</code> method is automatically declared to be private.</p>
<p>It's time for some examples.  Perhaps we're modeling an accounting system where every debit has a corresponding credit. Because we want to ensure that no one can break this rule, we'll make the methods that do the debits and credits private, and we'll define our external interface in terms of transactions.</p>

<div><code class="block">class Accounts

  private

    def debit(account, amount)
      account.balance -= amount
    end
    def credit(account, amount)
      account.balance += amount
    end

  public

    #...
    def transferToSavings(amount)
      debit(@checking, amount)
      credit(@savings, amount)
    end
    #...
end</code></div>

<p>Protected access is used when objects need to access the internal state of other objects of the same class.  For example, we may want to allow the individual <code class="class">Account</code> objects to compare their raw balances, but may want to hide those balances from the rest of the world (perhaps because we present them in a different form).</p>

<div><code class="block">class Account
  attr_reader :balance       # accessor method 'balance'

  protected :balance         # and make it protected

  def greaterBalanceThan(other)
    return @balance &gt; other.balance
  end
end</code></div>

<p>Because the attribute <code class="method">balance</code> is protected, it's available only within <code class="class">Account</code> objects.</p>

<h2 id="variables">Variables</h2>
<p>Now that we've gone to the trouble to create all these objects, let's make sure we don't lose them.  Variables are used to keep track of objects; each variable holds a reference to an object.</p>

<p>Let's confirm this with some code.</p>

<div><code class="block">person = "Tim"
person.id <span class="output"><span class="outputmark">&rarr;</span> 537771100</span>
person.type <span class="output"><span class="outputmark">&rarr;</span> String</span>
person <span class="output"><span class="outputmark">&rarr;</span> "Tim"</span></code></div>


<p>On the first line, Ruby creates a new <code>String</code> object with the value &ldquo;Tim.&rdquo; A reference to this object is placed in the local variable <var>person</var>. A quick check shows that the variable has indeed taken on the personality of a string, with an object id, a type, and a value.</p>
<p>So, is a variable an object?</p>
<p>In Ruby, the answer is &ldquo;no.&rdquo; A variable is simply a reference to an object. Objects float around in a big pool somewhere (the heap, most of the time) and are pointed to by variables.</p>
<p>Let's make the example slightly more complicated.</p>

<div><code class="block">  person1 = "Tim"
  person2 = person1

  person1[0] = 'J'

  person1 <span class="output"><span class="outputmark">&rarr;</span> "Jim"</span>
  person2 <span class="output"><span class="outputmark">&rarr;</span> "Jim"</span></code></div>


<p>What happened here? We changed the first character of <var>person1</var>, but both <var>person1</var> and <var>person2</var> changed from &ldquo;Tim&rdquo; to &ldquo;Jim.&rdquo;</p>
<p>It all comes back to the fact that variables hold references to objects, not the objects themselves. The assignment of <var>person1</var> to <var>person2</var> doesn't create any new objects; it simply copies <var>person1</var>'s object reference to <var>person2</var>, so that both <var>person1</var> and <var>person2</var> refer to the same object.  We show this in <a href="tut_classes.html#figure_3.1">Figure 3.1</a>.</p>

<div class="figure" id="figure_3.1">Figure 3.1 not available...</div>


<p>Assignment <em>aliases</em> objects, potentially giving you multiple variables that reference the same object. But can't this cause problems in your code?  It can, but not as often as you'd think (objects in Java, for example, work exactly the same way).  For instance, in the example in Figure 3.1, you could avoid aliasing by using the <code class="method">dup</code> method of <code class="class">String</code>, which creates a new <code class="class">String</code> object with identical contents.</p>

<div><code class="block">  person1 = "Tim"
  person2 = person1.dup
  person1[0] = "J"
  person1 <span class="output"><span class="outputmark">&rarr;</span> "Jim"</span>
  person2 <span class="output"><span class="outputmark">&rarr;</span> "Tim"</span></code></div>

<p>You can also prevent anyone from changing a particular object by freezing it (we talk more about freezing objects in the section &ldquo;<a href="classes.html#freezingobjects">Freezing Objects</a>&rdquo;). Attempt to alter a frozen object, and Ruby will raise a <code class="exception">TypeError</code> exception.</p>

<div><code class="block">person1 = "Tim"
person2 = person1
person1.freeze       # prevent modifications to the object
person2[0] = "J"</code></div>

<p class="produces"><em>produces:</em></p>
<div><code class="block">prog.rb:4:in `=': can't modify frozen string (TypeError)
    from prog.rb:4</code></div>


<div id="menubot" class="menu">
	<a href="intro.html" class="prev">&lt; Previous</a><a href="tut_containers.html" class="next">Next &gt;</a>
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div>

<div id="copyright">
	<p>Extracted from the book "Programming Ruby -  The Pragmatic Programmer's Guide"</p>
	<p>Copyright &copy; 2001 by Addison Wesley Longman, Inc. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at <a href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>).</p>
	<p>Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder.</p>
	<p>Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.</p>
</div>

<a href="tut_classes.html" target="_top" id="expand" title="Show this content in its own window" onclick="this.href=window.location.href"><img src="includes/expand.png" alt="Show this content in its own window" width="15" height="15"></a>
<script type="text/javascript">
	if (top==self && document.getElementById){
		ex = document.getElementById('expand');
		img = ex.getElementsByTagName('img')[0];
		ex.title=img.alt="Show this content alongside the Table of Contents";
		ex.onclick=function(){ return true }
		ex.href="frameset.html?content="+escape(self.location.href);
		img.src="includes/collapse.png";
	}
</script>
</body>
</html>
