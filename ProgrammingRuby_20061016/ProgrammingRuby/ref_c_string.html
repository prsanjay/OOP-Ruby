<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
	<title>String</title>
	<link rel="stylesheet" href="includes/styles.css" type="text/css" media="all">
</head>
<body>
<div id="header">
	<h1>Programming Ruby</h1>
	<h2>The Pragmatic Programmer's Guide</h2>
</div><div id="menutop" class="menu">
	
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div><script type="text/javascript">
	top.frames.toc && top.frames.toc.SyncChanges && top.frames.toc.SyncChanges(null,'ref_c_string',location.hash);
	top.document.title=document.title+' @ Programming Ruby';
</script>


<h1 class="class" id="String">class <strong>String</strong> &lt; Object</h1>

<p>A <code class="class">String</code> object holds and manipulates an arbitrary sequence       of bytes, typically representing characters. String objects may       be created using <code class="class_class_method"><a href="ref_c_string.html#String.new"><span class="class">String</span>.<span class="method">new</span></a></code> or as literals (see page       202).    Because of aliasing issues, users of strings should be aware of the   methods that modify the contents of a <code class="class">String</code> object. Typically,   methods with names ending in &ldquo;!&rdquo; modify their receiver, while those   without a &ldquo;!&rdquo; return a new <code class="class">String</code>. However, there are exceptions, such    as <code class="class_instance_method"><a href="ref_c_string.html#String._ob_cb_eq"><span class="class">String</span>#<span class="method">[]=</span></a></code>.</p>

<h2>mixins</h2>
<dl>
	<dt><code class="module"><a href="ref_m_comparable.html#Comparable">Comparable</a></code></dt>
	<dd><code class="module_instance_method"><a href="ref_m_comparable.html#Comparable._lt">&lt;</a></code>, <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable._lt_eq">&lt;=</a></code>, <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable.eqeq">==</a></code>, <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable._gt_eq">&gt;=</a></code>, <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable._gt">&gt;</a></code>, <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable.between">between?</a></code></dd>
	<dt><code class="module"><a href="ref_m_enumerable.html#Enumerable">Enumerable</a></code></dt>
	<dd><code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.collect">collect</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.detect">detect</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.each_with_index">each_with_index</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.entries">entries</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.find">find</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.find_all">find_all</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.grep">grep</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.include">include?</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.map">map</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.max">max</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.member">member?</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.min">min</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.reject">reject</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.select">select</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.sort">sort</a></code>, <code class="module_instance_method"><a href="ref_m_enumerable.html#Enumerable.to_a">to_a</a></code></dd>
</dl>


<h2 class="refsubsection" id="classmethods">class methods</h2>
<dl class="methodlist">
	<dt id="String.new">new</dt>
		<dd class="callseq">String.new( <i class="obj">aString</i> )  &rarr; <i class="obj">aNewString</i></dd>
		<dd class="desc">Returns a new string object containing a copy of <i class="obj">aString</i>.</dd>
</dl>

<h2 class="refsubsection" id="instancemethods">instance methods</h2>
<dl class="methodlist">
	<dt id="String._pc">%</dt>
		<dd class="callseq"><i class="obj">str</i> % <i class="obj">arg</i>  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Format&mdash;Uses <i class="obj">str</i> as a format specification, and returns the result of applying it to <i class="obj">arg</i>. If the format specification contains more than one substitution, then <i class="obj">arg</i> must be an <code class="class">Array</code> containing the values to be substituted. See <code class="module_module_method"><a href="ref_m_kernel.html#Kernel.sprintf"><span class="module">Kernel</span>::<span class="method">sprintf</span></a></code> for details of the format string.

<div><code class="block">"%05d" % 123 <span class="output"><span class="outputmark">&rarr;</span> "00123"</span>
"%-5s: %08x" % [ "ID", self.id ] <span class="output"><span class="outputmark">&rarr;</span> "ID&#8255;&#8255;&#8255;:&#8255;200e1670"</span></code></div>

		</dd>

	<dt id="String._st">*</dt>
		<dd class="callseq"><i class="obj">str</i> * <i class="obj">anInteger</i>  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Copy&mdash;Returns a new <code class="class">String</code> containing <i class="obj">anInteger</i> copies of
      the receiver.

<div><code class="block">"Ho! " * 3 <span class="output"><span class="outputmark">&rarr;</span> "Ho! Ho! Ho! "</span></code></div>

		</dd>

	<dt id="String._pl">+</dt>
		<dd class="callseq"><i class="obj">str</i> + <i class="obj">aString</i>  &rarr; <i class="obj">aNewString</i></dd>
		<dd class="desc">Concatenation&mdash;Returns a new <code class="class">String</code> containing
      <i class="obj">aString</i> concatenated to <i class="obj">str</i>.

<div><code class="block">"Hello from " + self.to_s <span class="output"><span class="outputmark">&rarr;</span> "Hello from main"</span></code></div>

		</dd>

	<dt id="String._lt_lt">&lt;&lt;</dt>
		<dd class="callseq"><i class="obj">str</i> &lt;&lt; <i class="obj">aFixnum</i>  &rarr; <i class="obj">str</i></dd>
		<dd class="callseq"><i class="obj">str</i> &lt;&lt; <i class="obj">anObject</i>  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Append&mdash;Concatenates the given object to <i class="obj">str</i>. If the object is a
      <code class="class">Fixnum</code> between 0 and 255, it is converted to a character
      before concatenation.

<div><code class="block">a = "hello "
a &lt;&lt; "world" <span class="output"><span class="outputmark">&rarr;</span> "hello world"</span>
a &lt;&lt; 33 <span class="output"><span class="outputmark">&rarr;</span> "hello world!"</span>
a <span class="output"><span class="outputmark">&rarr;</span> "hello world!"</span></code></div>

		</dd>

	<dt id="String._lt_eq_lt">&lt;=&gt;</dt>
		<dd class="callseq"><i class="obj">str</i> &lt;=&gt; <i class="obj">aString</i>  &rarr; -1, 0, +1</dd>
		<dd class="desc"><p>Comparison&mdash;Returns -1 if <i class="obj">str</i> is less than, 0 if <i class="obj">str</i> is equal to, and +1 if <i class="obj">str</i> is greater than <i class="obj">aString</i>. If the strings are of different lengths, and the strings are equal when compared up to the shortest length, then the longer string is considered greater than the shorter one. If the variable <var>$=</var> is <code class="const">false</code>, the comparison is based on comparing the binary values of each character in the string. If <var>$=</var> is not <code class="const">false</code>, then the comparison is case insensitive. <span class="footnote">(The locale is ignored when case-insensitive comparisons are performed, so &ldquo;\"o&rdquo; will not match &ldquo;\"O&rdquo;.)</span> </p> 

<p><code class="method">&lt;=&gt;</code> is the basis for the methods <code class="method">&lt;</code>, <code class="method">&lt;=</code>, <code class="method">&gt;</code>, <code class="method">&gt;=</code>, and <code class="method">between?</code>, included from module <code class="module">Comparable</code>. The method <code class="class_instance_method"><a href="ref_c_string.html#String._eq_eq"><span class="class">String</span>#<span class="method">==</span></a></code> does not use <code class="module_instance_method"><a href="ref_m_comparable.html#Comparable._eq_eq"><span class="module">Comparable</span>#<span class="method">==</span></a></code>.</p>

<div><code class="block">"abcdef" &lt;=&gt; "abcde" <span class="output"><span class="outputmark">&rarr;</span> 1</span>
"abcdef" &lt;=&gt; "abcdef" <span class="output"><span class="outputmark">&rarr;</span> 0</span>
"abcdef" &lt;=&gt; "abcdefg" <span class="output"><span class="outputmark">&rarr;</span> -1</span>
"abcdef" &lt;=&gt; "ABCDEF" <span class="output"><span class="outputmark">&rarr;</span> 1</span>
$= = true
"abcdef" &lt;=&gt; "ABCDEF" <span class="output"><span class="outputmark">&rarr;</span> 0</span></code></div>

		</dd>

	<dt id="String._eq_eq">==</dt>
		<dd class="callseq"><i class="obj">str</i> == <i class="obj">anObject</i>  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="desc">Equality&mdash;If <i class="obj">anObject</i> is not a <code class="class">String</code>, returns
      <code class="const">false</code>. Otherwise, returns <code class="const">true</code> if <i class="obj">str</i> <code>&lt;=&gt;</code>
      <i class="obj">anObject</i> returns zero.

		</dd>

	<dt id="String._eq_eq_eq">===</dt>
		<dd class="callseq"><i class="obj">str</i> === <i class="obj">anObject</i>  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="desc">Case Equality&mdash;Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String._eq_eq"><span class="class">String</span>#<span class="method">==</span></a></code>.

		</dd>

	<dt id="String._eq_sd">=~</dt>
		<dd class="callseq"><i class="obj">str</i> =~ <i class="obj">anObject</i>  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="desc">Match&mdash;If <i class="obj">anObject</i> is a <code class="class">Regexp</code> or a <code class="class">String</code>, uses it as a pattern to match against <i class="obj">str</i>.  Returns the position the match starts, or <code class="const">nil</code> if there is no match. Otherwise, invokes <i class="obj">anObject.=~</i>, passing <i class="obj">str</i> as an argument. The default <code>=~</code> in <code class="class">Object</code> returns <code class="const">false</code>.

<div><code class="block">"cat o' 9 tails" =~ "\\d" <span class="output"><span class="outputmark">&rarr;</span> 7</span>
"cat o' 9 tails" =~ /\d/ <span class="output"><span class="outputmark">&rarr;</span> 7</span>
"cat o' 9 tails" =~ 9 <span class="output"><span class="outputmark">&rarr;</span> false</span></code></div>

		</dd>

	<dt id="String._ob_cb">[ ]</dt>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aFixnum</i> ]  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aFixnum</i>, <i class="obj">aFixnum</i> ]  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aRange</i> ]  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aRegexp</i> ]  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aString</i> ]  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="desc"><p>Element Reference&mdash;If passed a single <code class="class">Fixnum</code>, returns the code of the character at that position. If passed two <code class="class">Fixnum</code> objects, returns a substring starting at the offset given by the first, and a length given by the second. If given a range, a substring containing characters at offsets given by the range is returned. In all three cases, if an offset is negative, it is counted from the end of <i class="obj">str</i>. Returns <code>nil</code> if the initial offset falls outside the string, the length is negative, or the beginning of the range is greater than the end.</p>

		<p>If a <code class="class">Regexp</code> is supplied, the matching portion of <i class="obj">str</i> is returned. If a <code class="class">String</code> is given, that string is returned if it occurs in <i class="obj">str</i>. In both cases, <code class="const">nil</code> is returned if there is no match.</p>

<div><code class="block">a = "hello there"
a[1] <span class="output"><span class="outputmark">&rarr;</span> 101</span>
a[1,3] <span class="output"><span class="outputmark">&rarr;</span> "ell"</span>
a[1..3] <span class="output"><span class="outputmark">&rarr;</span> "ell"</span>
a[-3,2] <span class="output"><span class="outputmark">&rarr;</span> "er"</span>
a[-4..-2] <span class="output"><span class="outputmark">&rarr;</span> "her"</span>
a[-2..-4] <span class="output"><span class="outputmark">&rarr;</span> nil</span>
a[/th[aeiou]/] <span class="output"><span class="outputmark">&rarr;</span> "the"</span>
a["lo"] <span class="output"><span class="outputmark">&rarr;</span> "lo"</span>
a["bye"] <span class="output"><span class="outputmark">&rarr;</span> nil</span></code></div>

		</dd>

	<dt id="String._ob_cb_eq">[ ]=</dt>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aFixnum</i> ] = <i class="obj">aFixnum</i></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aFixnum</i> ] = <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aFixnum</i>, <i class="obj">aFixnum</i> ] = <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aRange</i> ] = <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aRegexp</i> ] = <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>[ <i class="obj">aString</i> ] = <i class="obj">aString</i></dd>
		<dd class="desc"><p>Element Assignment&mdash;Replaces some or all of the content of <i class="obj">str</i>. The portion of the string affected is determined using the same criteria as <code class="class_instance_method"><a href="ref_c_string.html#String._ob_cb"><span class="class">String</span>#<span class="method">[]</span></a></code>. If the replacement string is not the same length as the text it is replacing, the string will be adjusted accordingly.</p>

		<p>The forms that take a <code class="class">Fixnum</code> will raise an <code class="exception">IndexError</code> if the value is out of range; the <code class="class">Range</code> form will raise a <code class="exception">RangeError</code>, and the <code class="class">Regexp</code> and <code class="class">String</code> forms will silently ignore the assignment.</p>

<div><code class="block">a = "hello"; a[2]       = 96;    a <span class="output"><span class="outputmark">&rarr;</span> "he`lo"</span>
a = "hello"; a[2, 4]    = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hexyz"</span>
a = "hello"; a[-4, 2]   = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hxyzlo"</span>
a = "hello"; a[2..4]    = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hexyz"</span>
a = "hello"; a[-4..-2]  = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hxyzo"</span>
a = "hello"; a[/[el]+/] = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hxyzo"</span>
a = "hello"; a["l"]     = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hexyzlo"</span>
a = "hello"; a["ll"]    = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hexyzo"</span>
a = "hello"; a["bad"]   = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
a = "hello"; a[2, 0]    = "xyz"; a <span class="output"><span class="outputmark">&rarr;</span> "hexyzllo"</span></code></div>

		</dd>

	<dt id="String._sd">~</dt>
		<dd class="callseq">~<i class="obj">str</i>  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="desc">Equivalent to <var>$_</var><code> =~ <i class="obj">str</i></code>.

		</dd>

	<dt id="String.capitalize">capitalize</dt>
		<dd class="callseq"><i class="obj">str</i>.capitalize  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with the first character converted to uppercase and the remainder to lowercase.

<div><code class="block">"hello".capitalize <span class="output"><span class="outputmark">&rarr;</span> "Hello"</span>
"HELLO".capitalize <span class="output"><span class="outputmark">&rarr;</span> "Hello"</span>
"123ABC".capitalize <span class="output"><span class="outputmark">&rarr;</span> "123abc"</span></code></div>

		</dd>

	<dt id="String.capitalize_oh">capitalize!</dt>
		<dd class="callseq"><i class="obj">str</i>.capitalize!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Modifies <i class="obj">str</i> by converting  the first character to
      uppercase and the remainder to lowercase. Returns <code class="const">nil</code> if
      no changes are made.

<div><code class="block">a = "hello"
a.capitalize! <span class="output"><span class="outputmark">&rarr;</span> "Hello"</span>
a <span class="output"><span class="outputmark">&rarr;</span> "Hello"</span>
a.capitalize! <span class="output"><span class="outputmark">&rarr;</span> nil</span></code></div>

		</dd>

	<dt id="String.center">center</dt>
		<dd class="callseq"><i class="obj">str</i>.center( <i class="obj">anInteger</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">If <i class="obj">anInteger</i> is greater than the length of <i class="obj">str</i>, returns a
      new <code class="class">String</code> of length <i class="obj">anInteger</i> with <i class="obj">str</i> centered
      between spaces; otherwise,
      returns <i class="obj">str</i>.

<div><code class="block">"hello".center(4) <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"hello".center(20) <span class="output"><span class="outputmark">&rarr;</span> "&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;hello&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;"</span></code></div>

		</dd>

	<dt id="String.chomp">chomp</dt>
		<dd class="callseq"><i class="obj">str</i>.chomp( <i class="obj">aString</i>=<var>$/</var> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a new <code class="class">String</code> with the given record separator removed
      from the end of <i class="obj">str</i> (if present).

<div><code class="block">"hello".chomp <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"hello\n".chomp <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"hello \n there".chomp <span class="output"><span class="outputmark">&rarr;</span> "hello \n there"</span>
"hello".chomp("llo") <span class="output"><span class="outputmark">&rarr;</span> "he"</span></code></div>

		</dd>

	<dt id="String.chomp_oh">chomp!</dt>
		<dd class="callseq"><i class="obj">str</i>.chomp!( <i class="obj">aString</i>=<var>$/</var> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Modifies <i class="obj">str</i> in place as described for <code class="class_instance_method"><a href="ref_c_string.html#String.chomp"><span class="class">String</span>#<span class="method">chomp</span></a></code>,
      returning <i class="obj">str</i>, or <code class="const">nil</code> if no modifications were made.
		</dd>

	<dt id="String.chop">chop</dt>
		<dd class="callseq"><i class="obj">str</i>.chop  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a new <code class="class">String</code> with the last character removed. If the string ends with <code>\r\n</code>, both characters are removed. Applying <code class="method">chop</code> to an empty string returns an empty string. <code class="class_instance_method"><a href="ref_c_string.html#String.chomp"><span class="class">String</span>#<span class="method">chomp</span></a></code> is often a safer alternative, as it leaves the string unchanged  if it doesn't end in a record separator.

<div><code class="block">"string\r\n".chop <span class="output"><span class="outputmark">&rarr;</span> "string"</span>
"string\n\r".chop <span class="output"><span class="outputmark">&rarr;</span> "string\n"</span>
"string\n".chop <span class="output"><span class="outputmark">&rarr;</span> "string"</span>
"string".chop <span class="output"><span class="outputmark">&rarr;</span> "strin"</span>
"x".chop.chop <span class="output"><span class="outputmark">&rarr;</span> ""</span></code></div>

		</dd>

	<dt id="String.chop_oh">chop!</dt>
		<dd class="callseq"><i class="obj">str</i>.chop!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Processes <i class="obj">str</i> as for <code class="class_instance_method"><a href="ref_c_string.html#String.chop"><span class="class">String</span>#<span class="method">chop</span></a></code>, returning <i class="obj">str</i>,
      or <code>nil</code> if <i class="obj">str</i> is the empty string.  See also
      <code class="class_instance_method"><a href="ref_c_string.html#String.chomp_oh"><span class="class">String</span>#<span class="method">chomp!</span></a></code>.

		</dd>

	<dt id="String.concat">concat</dt>
		<dd class="callseq"><i class="obj">str</i>.concat( <i class="obj">aFixnum</i> )  &rarr; <i class="obj">str</i></dd>
		<dd class="callseq"><i class="obj">str</i>.concat( <i class="obj">anObject</i> )  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String._lt_lt"><span class="class">String</span>#<span class="method">&lt;&lt;</span></a></code>.

		</dd>

	<dt id="String.count">count</dt>
		<dd class="callseq"><i class="obj">str</i>.count( <i>[</i><i class="obj">aString</i><i>]+</i> )  &rarr; <i class="obj">aFixnum</i></dd>
		<dd class="desc">Each <i class="obj">aString</i> parameter defines a set of characters to
      count. The intersection of these sets defines the characters to count
      in <i class="obj">str</i>. Any <i class="obj">aString</i> that starts with a caret (^) is
      negated. The sequence c<sub>1</sub>--c<sub>2</sub> means all characters between
      c<sub>1</sub> and c<sub>2</sub>.

<div><code class="block">a = "hello world"
a.count "lo" <span class="output"><span class="outputmark">&rarr;</span> 5</span>
a.count "lo", "o" <span class="output"><span class="outputmark">&rarr;</span> 2</span>
a.count "hello", "^l" <span class="output"><span class="outputmark">&rarr;</span> 4</span>
a.count "ej-m" <span class="output"><span class="outputmark">&rarr;</span> 4</span></code></div>

		</dd>

	<dt id="String.crypt">crypt</dt>
		<dd class="callseq"><i class="obj">str</i>.crypt( <i class="obj">aString</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Applies a one-way cryptographic hash to <i class="obj">str</i> by invoking the standard library function <code class="method">crypt</code>. The argument is the salt string, which should be two characters long, each character drawn from <code>[a-zA-Z0-9./]</code>.

		</dd>

	<dt id="String.delete">delete</dt>
		<dd class="callseq"><i class="obj">str</i>.delete( <i>[</i><i class="obj">aString</i><i>]+</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as <code class="class_instance_method"><a href="ref_c_string.html#String.count"><span class="class">String</span>#<span class="method">count</span></a></code>.

<div><code class="block">"hello".delete "l","lo" <span class="output"><span class="outputmark">&rarr;</span> "heo"</span>
"hello".delete "lo" <span class="output"><span class="outputmark">&rarr;</span> "he"</span>
"hello".delete "aeiou", "^e" <span class="output"><span class="outputmark">&rarr;</span> "hell"</span>
"hello".delete "ej-m" <span class="output"><span class="outputmark">&rarr;</span> "ho"</span></code></div>

		</dd>

	<dt id="String.delete_oh">delete!</dt>
		<dd class="callseq"><i class="obj">str</i>.delete!( <i>[</i><i class="obj">aString</i><i>]+</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Performs a <code>delete</code> operation in place, returning <i class="obj">str</i>, or <code class="const">nil</code> if <i class="obj">str</i> was not modified.</dd>

	<dt id="String.downcase">downcase</dt>
		<dd class="callseq"><i class="obj">str</i>.downcase  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with all uppercase letters replaced with their lowercase counterparts. The operation is locale insensitive&mdash;only characters &ldquo;A&rdquo; to &ldquo;Z&rdquo; are affected.

<div><code class="block">"hEllO".downcase <span class="output"><span class="outputmark">&rarr;</span> "hello"</span></code></div>

		</dd>

	<dt id="String.downcase_oh">downcase!</dt>
		<dd class="callseq"><i class="obj">str</i>.downcase!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Downcases the contents of <i class="obj">str</i>, returning <code class="const">nil</code> if no
      changes were made.
		</dd>

	<dt id="String.dump">dump</dt>
		<dd class="callseq"><i class="obj">str</i>.dump  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Produces a version of <i class="obj">str</i> with all nonprinting characters
      replaced by <code>\nnn</code> notation and all special characters
      escaped.

		</dd>

	<dt id="String.each">each</dt>
		<dd class="callseq"><i class="obj">str</i>.each( <i class="obj">aString</i>=<var>$/</var> ) {| substr | block } &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Splits <i class="obj">str</i> using the supplied parameter as the record separator (<var>$/</var> by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split on <code>\n</code> characters, except that multiple successive newlines are appended together.

<div><code class="block">print "Example one\n"
"hello\nworld".each {|s| p s}
print "Example two\n"
"hello\nworld".each('l') {|s| p s}
print "Example three\n"
"hello\n\n\nworld".each(&rdquo;) {|s| p s}</code></div>
<p class="produces"><em>produces:</em></p>
<div><code class="block">Example one
"hello\n"
"world"
Example two
"hel"
"l"
"o\nworl"
"d"
Example three
"hello\n\n\n"
"world"</code></div>

		</dd>

	<dt id="String.each_byte">each_byte</dt>
		<dd class="callseq"><i class="obj">str</i>.each_byte {| aFixnum | block }  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Passes each byte in <i class="obj">str</i> to the given block.

<div><code class="block">"hello".each_byte {|c| print c, ' ' }</code></div>
<p class="produces"><em>produces:</em></p>
<div><code class="block">104 101 108 108 111</code></div>

		</dd>

	<dt id="String.each_line">each_line</dt>
		<dd class="callseq"><i class="obj">str</i>.each_line( <i class="obj">aString</i>=<var>$/</var> ) {| substr | block } &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String.each"><span class="class">String</span>#<span class="method">each</span></a></code>.

		</dd>

	<dt id="String.empty_qm">empty?</dt>
		<dd class="callseq"><i class="obj">str</i>.empty?  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="desc">Returns <code class="const">true</code> if <i class="obj">str</i> has a length of zero.

<div><code class="block">"hello".empty? <span class="output"><span class="outputmark">&rarr;</span> false</span>
"".empty? <span class="output"><span class="outputmark">&rarr;</span> true</span></code></div>

		</dd>

	<dt id="String.gsub">gsub</dt>
		<dd class="callseq"><i class="obj">str</i>.gsub( <i class="obj">pattern</i>, <i class="obj">replacement</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>.gsub( <i class="obj">pattern</i> ) {| match | block } &rarr; <i class="obj">aString</i></dd>
		<dd class="desc"><p>Returns a copy of <i class="obj">str</i> with <em>all</em> occurrences of <i class="obj">pattern</i> replaced with either <i class="obj">replacement</i> or the value of the block. If a string is used as the replacement, special variables from the match (such as <var>$&amp;</var> and <var>$1</var>) cannot be substituted into it, as substitution into the string occurs before the pattern match starts. However, the sequences <code>\1</code>, <code>\2</code>, and so on may be used to interpolate successive groups in the match. These sequences are shown in <a href="ref_c_string.html#table_22.7">Table 22.7</a>.</p>
      
		<table id="table_22.7">
			<caption>Table 22.7 : Backslash sequences in substitution strings</caption>
			<thead><tr>
	<th>Sequence</th>
	<th>Text That Is Substituted</th>
</tr></thead>
			<tr class="firstRow">
				<td><code>\1, \2, ... \9</code></td>
				<td>The value matched by the <em>n</em>th grouped subexpression</td>
			</tr>
			<tr>
				<td><code>\&amp;</code></td>
				<td>The last match</td>
			</tr>
			<tr>
				<td><code>\`</code></td>
				<td>The part of the string before the match</td>
			</tr>
			<tr>
				<td><code>\'</code></td>
				<td>The part of the string after the match</td>
			</tr>
			<tr>
				<td><code>\+</code></td>
				<td>The highest-numbered group matched</td>
			</tr>
		</table>

		<p>In the block form, the current match is passed in as a parameter, and variables such as <var>$1</var>, <var>$2</var>, <var>$`</var>, <var>$&amp;</var>, and <var>$'</var> will be set appropriately. The value returned by the block will be substituted for the match on each call.</p>
		
		<p>The result inherits any tainting in the original string or any supplied replacement string.</p>

<div><code class="block">"hello".gsub(/[aeiou]/, '*') <span class="output"><span class="outputmark">&rarr;</span> "h*ll*"</span>
"hello".gsub(/([aeiou])/, '&lt;\1&gt;') <span class="output"><span class="outputmark">&rarr;</span> "h&lt;e&gt;ll&lt;o&gt;"</span>
"hello".gsub('.') {|s| s[0].to_s + ' '} <span class="output"><span class="outputmark">&rarr;</span> "104 101 108 108 111 "</span></code></div>

		</dd>

	<dt id="String.gsub_oh">gsub!</dt>
		<dd class="callseq"><i class="obj">str</i>.gsub!( <i class="obj">pattern</i>, <i class="obj">replacement</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.gsub!( <i class="obj">pattern</i> ) {| match | block } &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Performs the substitutions of <code class="class_instance_method"><a href="ref_c_string.html#String.gsub"><span class="class">String</span>#<span class="method">gsub</span></a></code> in place, returning <i class="obj">str</i>, or <code>nil</code> if no substitutions were performed.</dd>

	<dt id="String.hash">hash</dt>
		<dd class="callseq"><i class="obj">str</i>.hash  &rarr; <i class="obj">aFixnum</i></dd>
		<dd class="desc">Generates a <code class="class">Fixnum</code> hash value for <i class="obj">str</i>. If <var>$=</var> is
      <code class="const">true</code>, the hash will be case insensitive.

<div><code class="block">$= = true
hash = { 'cat' =&gt; 'Feline', 'dog' =&gt; 'canine' }
hash['cat'] <span class="output"><span class="outputmark">&rarr;</span> "Feline"</span>
hash['cAt'] <span class="output"><span class="outputmark">&rarr;</span> "Feline"</span>
$= = false
hash.rehash     # re-calculate hash values
<span class="output"><span class="outputmark">&rarr;</span> {"cat"=&gt;"Feline", "dog"=&gt;"canine"}</span>

hash['cat'] <span class="output"><span class="outputmark">&rarr;</span> "Feline"</span>
hash['cAt'] <span class="output"><span class="outputmark">&rarr;</span> nil</span></code></div>

		</dd>

	<dt id="String.hex">hex</dt>
		<dd class="callseq"><i class="obj">str</i>.hex  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Treats leading characters from <i class="obj">str</i> as a string of hexadecimal
      digits (with an optional sign and an optional <code>0x</code>) and
      returns the corresponding number. Zero is returned on error.

<div><code class="block">"0x0a".hex <span class="output"><span class="outputmark">&rarr;</span> 10</span>
"-1234".hex <span class="output"><span class="outputmark">&rarr;</span> -4660</span>
"0".hex <span class="output"><span class="outputmark">&rarr;</span> 0</span>
"wombat".hex <span class="output"><span class="outputmark">&rarr;</span> 0</span></code></div>

		</dd>

	<dt id="String.include_qm">include?</dt>
		<dd class="callseq"><i class="obj">str</i>.include? <i class="obj">aString</i>  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="callseq"><i class="obj">str</i>.include? <i class="obj">aFixnum</i>  &rarr; <code class="const">true</code> or <code class="const">false</code></dd>
		<dd class="desc">Returns <code class="const">true</code> if <i class="obj">str</i> contains the given string or character.

<div><code class="block">"hello".include? "lo" <span class="output"><span class="outputmark">&rarr;</span> true</span>
"hello".include? "ol" <span class="output"><span class="outputmark">&rarr;</span> false</span>
"hello".include? ?h <span class="output"><span class="outputmark">&rarr;</span> true</span></code></div>

		</dd>

	<dt id="String.index">index</dt>
		<dd class="callseq"><i class="obj">str</i>.index( <i class="obj">aString</i> [, <i class="obj">anOffset</i>] )  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.index( <i class="obj">aFixnum</i> [, <i class="obj">anOffset</i>] ) &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.index( <i class="obj">aRegexp</i> [, <i class="obj">anOffset</i>] ) &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="desc">Returns the index of the first occurrence of the given substring,
      character, or pattern in <i class="obj">str</i>. Returns <code class="const">nil</code> if not found.
      If the second parameter is present, it specifies the position in
      the string to begin the search.

<div><code class="block">"hello".index('e') <span class="output"><span class="outputmark">&rarr;</span> 1</span>
"hello".index('lo') <span class="output"><span class="outputmark">&rarr;</span> 3</span>
"hello".index('a') <span class="output"><span class="outputmark">&rarr;</span> nil</span>
"hello".index(101) <span class="output"><span class="outputmark">&rarr;</span> 1</span>
"hello".index(/[aeiou]/, -3) <span class="output"><span class="outputmark">&rarr;</span> 4</span></code></div>

		</dd>

	<dt id="String.intern">intern</dt>
		<dd class="callseq"><i class="obj">str</i>.intern  &rarr; <i class="obj">aSymbol</i></dd>
		<dd class="desc">Returns the <code class="class">Symbol</code> corresponding to <i class="obj">str</i>, creating the symbol if it did not previously exist. See <code class="class_instance_method"><a href="ref_c_symbol.html#Symbol.id2name"><span class="class">Symbol</span>#<span class="method">id2name</span></a></code>.

<div><code class="block">"Koala".intern <span class="output"><span class="outputmark">&rarr;</span> :Koala</span></code></div>

		</dd>

	<dt id="String.length">length</dt>
		<dd class="callseq"><i class="obj">str</i>.length  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Returns the length of <i class="obj">str</i>.

		</dd>

	<dt id="String.ljust">ljust</dt>
		<dd class="callseq"><i class="obj">str</i>.ljust( <i class="obj">anInteger</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">If <i class="obj">anInteger</i> is greater than the length of <i class="obj">str</i>, returns a
      new <code class="class">String</code> of length <i class="obj">anInteger</i> with <i class="obj">str</i> left
      justified and space padded; otherwise, returns <i class="obj">str</i>.

<div><code class="block">"hello".ljust(4) <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"hello".ljust(20) <span class="output"><span class="outputmark">&rarr;</span> "hello&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;"</span></code></div>

		</dd>

	<dt id="String.next">next</dt>
		<dd class="callseq"><i class="obj">str</i>.next  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String.succ"><span class="class">String</span>#<span class="method">succ</span></a></code>.

		</dd>

	<dt id="String.next_oh">next!</dt>
		<dd class="callseq"><i class="obj">str</i>.next!  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String.succ_oh"><span class="class">String</span>#<span class="method">succ!</span></a></code>.

		</dd>

	<dt id="String.oct">oct</dt>
		<dd class="callseq"><i class="obj">str</i>.oct  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Treats leading characters of <i class="obj">str</i> as a string of octal digits (with an optional
      sign) and returns the corresponding number.  Returns 0 if the
      conversion fails.

<div><code class="block">"123".oct <span class="output"><span class="outputmark">&rarr;</span> 83</span>
"-377".oct <span class="output"><span class="outputmark">&rarr;</span> -255</span>
"bad".oct <span class="output"><span class="outputmark">&rarr;</span> 0</span>
"0377bad".oct <span class="output"><span class="outputmark">&rarr;</span> 255</span></code></div>

		</dd>

	<dt id="String.replace">replace</dt>
		<dd class="callseq"><i class="obj">str</i>.replace( <i class="obj">aString</i> )  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Replaces the contents and taintedness of <i class="obj">str</i> with the
      corresponding values in <i class="obj">aString</i>.

<div><code class="block">s = "hello" <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
s.replace "world" <span class="output"><span class="outputmark">&rarr;</span> "world"</span></code></div>

		</dd>

	<dt id="String.reverse">reverse</dt>
		<dd class="callseq"><i class="obj">str</i>.reverse  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a new string  with the characters from <i class="obj">str</i> in
      reverse order.

<div><code class="block">"stressed".reverse <span class="output"><span class="outputmark">&rarr;</span> "desserts"</span></code></div>

		</dd>

	<dt id="String.reverse_oh">reverse!</dt>
		<dd class="callseq"><i class="obj">str</i>.reverse!  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Reverses <i class="obj">str</i> in place.
		</dd>

	<dt id="String.rindex">rindex</dt>
		<dd class="callseq"><i class="obj">str</i>.rindex( <i class="obj">aString</i> [, <i class="obj">aFixnum</i>] )  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.rindex( <i class="obj">aFixnum</i> [, <i class="obj">aFixnum</i>] ) &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.rindex( <i class="obj">aRegexp</i> [, <i class="obj">aFixnum</i>] ) &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="desc">Returns the index of the last occurrence of the given substring, character, or pattern in <i class="obj">str</i>. Returns <code class="const">nil</code> if not found. If the second parameter is present, it specifies the position in the string to end the search&mdash;characters beyond this point will not be considered.

<div><code class="block">"hello".rindex('e') <span class="output"><span class="outputmark">&rarr;</span> 1</span>
"hello".rindex('l') <span class="output"><span class="outputmark">&rarr;</span> 3</span>
"hello".rindex('a') <span class="output"><span class="outputmark">&rarr;</span> nil</span>
"hello".rindex(101) <span class="output"><span class="outputmark">&rarr;</span> 1</span>
"hello".rindex(/[aeiou]/, -2) <span class="output"><span class="outputmark">&rarr;</span> 1</span></code></div>

		</dd>

	<dt id="String.rjust">rjust</dt>
		<dd class="callseq"><i class="obj">str</i>.rjust( <i class="obj">anInteger</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">If <i class="obj">anInteger</i> is greater than the length of <i class="obj">str</i>,
      returns a new <code class="class">String</code> of length
      <i class="obj">anInteger</i> with <i class="obj">str</i> right justified and space padded;
      otherwise, returns <i class="obj">str</i>.

<div><code class="block">"hello".rjust(4) <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"hello".rjust(20) <span class="output"><span class="outputmark">&rarr;</span> "&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;&#8255;hello"</span></code></div>

		</dd>

	<dt id="String.scan">scan</dt>
		<dd class="callseq"><i class="obj">str</i>.scan( <i class="obj">pattern</i> )  &rarr; <i class="obj">anArray</i></dd>
		<dd class="callseq"><i class="obj">str</i>.scan( <i class="obj">pattern</i> ) {| match, ...| block }  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Both forms iterate through <i class="obj">str</i>, matching the pattern (which may be a <code class="class">Regexp</code> or a <code class="class">String</code>). For each match, a result is generated and either added to the result array or passed to the block. If the pattern contains no groups, each individual result consists of the matched string, <code>$&amp;</code>. If the pattern contains groups, each individual result is itself an array containing one entry per group.

<div><code class="block">a = "cruel world"
a.scan(/\w+/) <span class="output"><span class="outputmark">&rarr;</span> ["cruel", "world"]</span>
a.scan(/.../) <span class="output"><span class="outputmark">&rarr;</span> ["cru", "el ", "wor"]</span>
a.scan(/(...)/) <span class="output"><span class="outputmark">&rarr;</span> [["cru"], ["el "], ["wor"]]</span>
a.scan(/(..)(..)/) <span class="output"><span class="outputmark">&rarr;</span> [["cr", "ue"], ["l ", "wo"]]</span></code></div>

      And the block form:

<div><code class="block">a.scan(/\w+/) {|w| print "&lt;&lt;#{w}&gt;&gt; " }
print "\n"
a.scan(/(.)(.)/) {|a,b| print b, a }
print "\n"</code></div>
<p class="produces"><em>produces:</em></p>
<div><code class="block">&lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
rceu lowlr</code></div>

		</dd>

	<dt id="String.size">size</dt>
		<dd class="callseq"><i class="obj">str</i>.size  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String.length"><span class="class">String</span>#<span class="method">length</span></a></code>.

		</dd>

	<dt id="String.slice">slice</dt>
		<dd class="callseq"><i class="obj">str</i>.slice( <i class="obj">aFixnum</i> )  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice( <i class="obj">aFixnum</i>, <i class="obj">aFixnum</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice( <i class="obj">aRange</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice( <i class="obj">aRegexp</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice( <i class="obj">aString</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String._ob_cb"><span class="class">String</span>#<span class="method">[ ]</span></a></code>.

<div><code class="block">a = "hello there"
a.slice(1) <span class="output"><span class="outputmark">&rarr;</span> 101</span>
a.slice(1,3) <span class="output"><span class="outputmark">&rarr;</span> "ell"</span>
a.slice(1..3) <span class="output"><span class="outputmark">&rarr;</span> "ell"</span>
a.slice(-3,2) <span class="output"><span class="outputmark">&rarr;</span> "er"</span>
a.slice(-4..-2) <span class="output"><span class="outputmark">&rarr;</span> "her"</span></code></div>

<div><code class="block">a.slice(-2..-4) <span class="output"><span class="outputmark">&rarr;</span> nil</span>
a.slice(/th[aeiou]/) <span class="output"><span class="outputmark">&rarr;</span> "the"</span>
a.slice("lo") <span class="output"><span class="outputmark">&rarr;</span> "lo"</span>
a.slice("bye") <span class="output"><span class="outputmark">&rarr;</span> nil</span></code></div>

		</dd>

	<dt id="String.slice_oh">slice!</dt>
		<dd class="callseq"><i class="obj">str</i>.slice!( <i class="obj">aFixnum</i> )  &rarr; <i class="obj">aFixnum</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice!( <i class="obj">aFixnum</i>, <i class="obj">aFixnum</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice!( <i class="obj">aRange</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice!( <i class="obj">aRegexp</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.slice!( <i class="obj">aString</i> )  &rarr; <i class="obj">aString</i> or <code>nil</code></dd>
		<dd class="desc">Deletes the specified portion from <i class="obj">str</i>, and returns the portion
      deleted.         The forms that take a <code class="class">Fixnum</code> will raise an
        <code class="exception">IndexError</code> if the value is out of range; the <code class="class">Range</code>
        form will raise a <code class="exception">RangeError</code>, and the <code class="class">Regexp</code> and
        <code class="class">String</code> forms will silently ignore the assignment.

<div><code class="block">string = "this is a string"
string.slice!(2) <span class="output"><span class="outputmark">&rarr;</span> 105</span>
string.slice!(3..6) <span class="output"><span class="outputmark">&rarr;</span> " is "</span>
string.slice!(/s.*t/) <span class="output"><span class="outputmark">&rarr;</span> "sa st"</span>
string.slice!("r") <span class="output"><span class="outputmark">&rarr;</span> "r"</span>
string <span class="output"><span class="outputmark">&rarr;</span> "thing"</span></code></div>

		</dd>

	<dt id="String.split">split</dt>
		<dd class="callseq"><i class="obj">str</i>.split( <i class="obj">pattern</i>=<var>$;</var>, [<i class="obj">limit</i>] )  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc"><p>Divides <i class="obj">str</i> into substrings based on a delimiter, returning an array of these substrings.</p>
		<p>If <i class="obj">pattern</i> is a <code class="class">String</code>, then its contents are used as the delimiter when splitting <i class="obj">str</i>. If <i class="obj">pattern</i> is a single space, <i class="obj">str</i> is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored.</p>
		<p>If <i class="obj">pattern</i> is a <code class="class">Regexp</code>, <i class="obj">str</i> is divided where the pattern matches. Whenever the pattern matches a zero-length string, <i class="obj">str</i> is split into individual characters.</p>
		<p>If <i class="obj">pattern</i> is omitted, the value of <var>$;</var> is used. If <var>$;</var> is <code class="const">nil</code> (which is the default), <i class="obj">str</i> is split on whitespace as if `&#8255;' were specified.</p>
		<p>If the <i class="obj">limit</i> parameter is omitted, trailing null fields are supressed. If <i class="obj">limit</i> is a positive number, at most that number of fields will be returned (if <i class="obj">limit</i> is <code>1</code>, the entire string is returned as the only entry in an array). If negative, there is no limit to the number of fields returned, and trailing null fields are not supressed.</p>

<div><code class="block">" now's  the time".split <span class="output"><span class="outputmark">&rarr;</span> ["now's", "the", "time"]</span>
" now's  the time".split(' ') <span class="output"><span class="outputmark">&rarr;</span> ["now's", "the", "time"]</span>
" now's  the time".split(/ /) <span class="output"><span class="outputmark">&rarr;</span> ["", "now's", "", "the", "time"]</span>
"1, 2.34,56, 7".split(/,\s*/) <span class="output"><span class="outputmark">&rarr;</span> ["1", "2.34", "56", "7"]</span>
"hello".split(//) <span class="output"><span class="outputmark">&rarr;</span> ["h", "e", "l", "l", "o"]</span>
"hello".split(//, 3) <span class="output"><span class="outputmark">&rarr;</span> ["h", "e", "llo"]</span>
"hi mom".split(/\s*/) <span class="output"><span class="outputmark">&rarr;</span> ["h", "i", "m", "o", "m"]</span></code></div>

<div><code class="block">"mellow yellow".split("ello") <span class="output"><span class="outputmark">&rarr;</span> ["m", "w y", "w"]</span>
"1,2,,3,4,,".split(',') <span class="output"><span class="outputmark">&rarr;</span> ["1", "2", "", "3", "4"]</span>
"1,2,,3,4,,".split(',', 4) <span class="output"><span class="outputmark">&rarr;</span> ["1", "2", "", "3,4,,"]</span>
"1,2,,3,4,,".split(',', -4) <span class="output"><span class="outputmark">&rarr;</span> ["1", "2", "", "3", "4", "", ""]</span></code></div>

		</dd>

	<dt id="String.squeeze">squeeze</dt>
		<dd class="callseq"><i class="obj">str</i>.squeeze( <i>[</i><i class="obj">aString</i><i>]*</i> )  &rarr; <i class="obj">aNewString</i></dd>
		<dd class="desc">Builds a set of characters from the <i class="obj">aString</i> parameter(s) using the procedure described for <code class="class_instance_method"><a href="ref_c_string.html#String.count"><span class="class">String</span>#<span class="method">count</span></a></code>. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character. 

<div><code class="block">"yellow moon".squeeze <span class="output"><span class="outputmark">&rarr;</span> "yelow mon"</span>
"  now   is  the".squeeze(" ") <span class="output"><span class="outputmark">&rarr;</span> " now is the"</span>
"putters shoot balls".squeeze("m-z") <span class="output"><span class="outputmark">&rarr;</span> "puters shot balls"</span></code></div>

		</dd>

	<dt id="String.squeeze_oh">squeeze!</dt>
		<dd class="callseq"><i class="obj">str</i>.squeeze!( <i>[</i><i class="obj">aString</i><i>]*</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Squeezes <i class="obj">str</i> in place, returning either <i class="obj">str</i>, or
      <code class="const">nil</code> if no changes were made.
		</dd>

	<dt id="String.strip">strip</dt>
		<dd class="callseq"><i class="obj">str</i>.strip  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with leading and trailing whitespace removed.

<div><code class="block">"    hello    ".strip <span class="output"><span class="outputmark">&rarr;</span> "hello"</span>
"\tgoodbye\r\n".strip <span class="output"><span class="outputmark">&rarr;</span> "goodbye"</span></code></div>

		</dd>

	<dt id="String.strip_oh">strip!</dt>
		<dd class="callseq"><i class="obj">str</i>.strip!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Removes leading and trailing whitespace from <i class="obj">str</i>. Returns
      <code class="const">nil</code> if <i class="obj">str</i> was not altered.
		</dd>

	<dt id="String.sub">sub</dt>
		<dd class="callseq"><i class="obj">str</i>.sub( <i class="obj">pattern</i>, <i class="obj">replacement</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="callseq"><i class="obj">str</i>.sub( <i class="obj">pattern</i> ) {| match | block } &rarr; <i class="obj">aString</i></dd>
		<dd class="desc"><p>Returns a copy of <i class="obj">str</i> with the <em>first</em> occurrence of <i class="obj">pattern</i> replaced with either <i class="obj">replacement</i> or the value of the block. If the string form of the method is used, special variables such as <var>$&amp;</var> will not be useful, as substitution into the string occurs before the pattern match starts. However, the sequences <code>\1</code>, <code>\2</code>, listed in <a href="ref_c_string.html#table_22.7">Table 22.7</a> may be used.</p>
		<p>In the block form, the current match is passed in as a parameter, and variables such as <var>$1</var>, <var>$2</var>, <var>$`</var>,         <var>$&amp;</var>, and <var>$'</var>        will be set appropriately. The value returned by the block will be substituted for the match on each call.</p>

<div><code class="block">"hello".sub(/[aeiou]/, '*') <span class="output"><span class="outputmark">&rarr;</span> "h*llo"</span>
"hello".sub(/([aeiou])/, '&lt;\1&gt;') <span class="output"><span class="outputmark">&rarr;</span> "h&lt;e&gt;llo"</span>
"hello".sub('.') {|s| s[0].to_s + ' ' } <span class="output"><span class="outputmark">&rarr;</span> "104 ello"</span></code></div>

		</dd>

	<dt id="String.sub_oh">sub!</dt>
		<dd class="callseq"><i class="obj">str</i>.sub!( <i class="obj">pattern</i>, <i class="obj">replacement</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="callseq"><i class="obj">str</i>.sub!( <i class="obj">pattern</i> ) {| match | block } &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Performs the substitutions of <code class="class_instance_method"><a href="ref_c_string.html#String.sub"><span class="class">String</span>#<span class="method">sub</span></a></code> in place,
      returning <i class="obj">str</i>, or <code class="const">nil</code> if no substitutions were
      performed.
		</dd>

	<dt id="String.succ">succ</dt>
		<dd class="callseq"><i class="obj">str</i>.succ  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc"><p>Returns the successor to <i class="obj">str</i>. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set's collating sequence.</p>
		<p>If the increment generates a &ldquo;carry,&rdquo; the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary.</p>

<div><code class="block">"abcd".succ <span class="output"><span class="outputmark">&rarr;</span> "abce"</span>
"THX1138".succ <span class="output"><span class="outputmark">&rarr;</span> "THX1139"</span>
"&lt;&lt;koala&gt;&gt;".succ <span class="output"><span class="outputmark">&rarr;</span> "&lt;&lt;koalb&gt;&gt;"</span>
"1999zzz".succ <span class="output"><span class="outputmark">&rarr;</span> "2000aaa"</span>
"ZZZ9999".succ <span class="output"><span class="outputmark">&rarr;</span> "AAAA0000"</span>
"***".succ <span class="output"><span class="outputmark">&rarr;</span> "**+"</span></code></div>

		</dd>

	<dt id="String.succ_oh">succ!</dt>
		<dd class="callseq"><i class="obj">str</i>.succ!  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Equivalent to <code class="class_instance_method"><a href="ref_c_string.html#String.succ"><span class="class">String</span>#<span class="method">succ</span></a></code>, but modifies the receiver in place.
		</dd>

	<dt id="String.sum">sum</dt>
		<dd class="callseq"><i class="obj">str</i>.sum( <i class="obj">aFixnum</i>=16 )  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Returns a basic
      <em>n</em>-bit checksum of the characters in
      <i class="obj">str</i>, where <em>n</em> is the optional parameter, defaulting to 16. The
      result is simply the sum of the binary value of each character
      in <i class="obj">str</i> modulo 2<sup>n</sup> - 1. This is not a particularly good checksum.

		</dd>

	<dt id="String.swapcase">swapcase</dt>
		<dd class="callseq"><i class="obj">str</i>.swapcase  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase.

<div><code class="block">"Hello".swapcase <span class="output"><span class="outputmark">&rarr;</span> "hELLO"</span>
"cYbEr_PuNk11".swapcase <span class="output"><span class="outputmark">&rarr;</span> "CyBeR_pUnK11"</span></code></div>

		</dd>

	<dt id="String.swapcase_oh">swapcase!</dt>
		<dd class="callseq"><i class="obj">str</i>.swapcase!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Equivalent to <code class="class_instance_method"><a href="ref_c_string.html#String.swapcase"><span class="class">String</span>#<span class="method">swapcase</span></a></code>, but modifies the receiver in place, returning <i class="obj">str</i>, or <code class="const">nil</code> if no changes were made.</dd>

	<dt id="String.to_f">to_f</dt>
		<dd class="callseq"><i class="obj">str</i>.to_f  &rarr; <i class="obj">aFloat</i></dd>
		<dd class="desc">Returns the result of interpreting leading characters in <i class="obj">str</i>
      as a floating point number. Extraneous characters past the end
      of a valid number are ignored. If there is not a valid number at
      the start of <i class="obj">str</i>, <code>0.0</code> is returned. The method never
      raises an exception.

<div><code class="block">"123.45e1".to_f <span class="output"><span class="outputmark">&rarr;</span> 1234.5</span>
"45.67 degrees".to_f <span class="output"><span class="outputmark">&rarr;</span> 45.67</span>
"thx1138".to_f <span class="output"><span class="outputmark">&rarr;</span> 0.0</span></code></div>

		</dd>

	<dt id="String.to_i">to_i</dt>
		<dd class="callseq"><i class="obj">str</i>.to_i  &rarr; <i class="obj">anInteger</i></dd>
		<dd class="desc">Returns the result of interpreting leading characters in <i class="obj">str</i>
      as a decimal integer. Extraneous characters past the end
      of a valid number are ignored. If there is not a valid number at
      the start of <i class="obj">str</i>, <code>0</code> is returned. The method never
      raises an exception.

<div><code class="block">"12345".to_i <span class="output"><span class="outputmark">&rarr;</span> 12345</span>
"99 red balloons".to_i <span class="output"><span class="outputmark">&rarr;</span> 99</span>
"0x0a".to_i <span class="output"><span class="outputmark">&rarr;</span> 0</span>
"hello".to_i <span class="output"><span class="outputmark">&rarr;</span> 0</span></code></div>

		</dd>

	<dt id="String.to_s">to_s</dt>
		<dd class="callseq"><i class="obj">str</i>.to_s  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Returns the receiver.

		</dd>

	<dt id="String.to_str">to_str</dt>
		<dd class="callseq"><i class="obj">str</i>.to_str  &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Synonym for <code class="class_instance_method"><a href="ref_c_string.html#String.to_s"><span class="class">String</span>#<span class="method">to_s</span></a></code>. <code class="method">to_str</code> is used by methods such as <code class="class_instance_method"><a href="ref_c_string.html#String.concat"><span class="class">String</span>#<span class="method">concat</span></a></code> to convert their arguments to a string. Unlike <code class="method">to_s</code>, which is supported by almost all classes, <code class="method">to_str</code> is normally implemented only by those classes that act like strings. Of the built-in classes, only <code class="class">Exception</code> and <code class="class">String</code> implement <code class="method">to_str</code>.

		</dd>

	<dt id="String.tr">tr</dt>
		<dd class="callseq"><i class="obj">str</i>.tr( <i class="obj">fromString</i>, <i class="obj">toString</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with the characters in
      <i class="obj">fromString</i> replaced by the corresponding characters in
      <i class="obj">toString</i>. If <i class="obj">toString</i> is shorter than
      <i class="obj">fromString</i>, it is padded with its last character. Both
      strings may use the c<sub>1</sub>--c<sub>2</sub> notation to denote ranges of
      characters, and <i class="obj">fromString</i> may start with a <code>^</code>,
      which denotes all characters except those listed.

<div><code class="block">"hello".tr('aeiou', '*') <span class="output"><span class="outputmark">&rarr;</span> "h*ll*"</span>
"hello".tr('^aeiou', '*') <span class="output"><span class="outputmark">&rarr;</span> "*e**o"</span>
"hello".tr('el', 'ip') <span class="output"><span class="outputmark">&rarr;</span> "hippo"</span>
"hello".tr('a-y', 'b-z') <span class="output"><span class="outputmark">&rarr;</span> "ifmmp"</span></code></div>

		</dd>

	<dt id="String.tr_oh">tr!</dt>
		<dd class="callseq"><i class="obj">str</i>.tr!( <i class="obj">fromString</i>, <i class="obj">toString</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Translates <i class="obj">str</i> in place, using the same rules as
      <code class="class_instance_method"><a href="ref_c_string.html#String.tr"><span class="class">String</span>#<span class="method">tr</span></a></code>. Returns <i class="obj">str</i>, or <code class="const">nil</code> if no changes were
      made.
		</dd>

	<dt id="String.tr_s">tr_s</dt>
		<dd class="callseq"><i class="obj">str</i>.tr_s( <i class="obj">fromString</i>, <i class="obj">toString</i> )  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Processes a copy of <i class="obj">str</i> as described under <code class="class_instance_method"><a href="ref_c_string.html#String.tr"><span class="class">String</span>#<span class="method">tr</span></a></code>,
      then removes duplicate characters in regions that were affected
      by the translation.

<div><code class="block">"hello".tr_s('l', 'r') <span class="output"><span class="outputmark">&rarr;</span> "hero"</span>
"hello".tr_s('el', '*') <span class="output"><span class="outputmark">&rarr;</span> "h*o"</span>
"hello".tr_s('el', 'hx') <span class="output"><span class="outputmark">&rarr;</span> "hhxo"</span></code></div>

		</dd>

	<dt id="String.tr_s_oh">tr_s!</dt>
		<dd class="callseq"><i class="obj">str</i>.tr_s!( <i class="obj">fromString</i>, <i class="obj">toString</i> )  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Performs <code class="class_instance_method"><a href="ref_c_string.html#String.tr_s"><span class="class">String</span>#<span class="method">tr_s</span></a></code> processing on <i class="obj">str</i> in place,
      returning <i class="obj">str</i>, or <code class="const">nil</code> if no changes were made.
		</dd>

	<dt id="String.unpack">unpack</dt>
		<dd class="callseq"><i class="obj">str</i>.unpack( <i class="obj">format</i> )  &rarr; <i class="obj">anArray</i></dd>
		<dd class="desc"><p>Decodes <i class="obj">str</i> (which may contain binary data) according to the format string, returning an array of each value extracted.  The format string consists of a sequence of single-character directives, summarized in <a href="ref_c_string.html#table_22.8">Table 22.8</a>.  Each directive may be followed by a number, indicating the number of times to repeat with this directive.  An asterisk (&ldquo;<code>*</code>&rdquo;) will use up all remaining elements.  The directives <code>sSiIlL</code> may each be followed by an underscore (&ldquo;<code>_</code>&rdquo;) to use the underlying platform's native size for the specified type; otherwise, it uses a platform-independent consistent size.  Spaces are ignored in the format string. See also <code class="class_instance_method"><a href="ref_c_array.html#Array.pack"><span class="class">Array</span>#<span class="method">pack</span></a></code>.</p> 

	<table id="table_22.8">
        <caption>Table 22.8 : Directives for <code class="class_instance_method"><a href="ref_c_string.html#String.unpack"><span class="class">String</span>#<span class="method">unpack</span></a></code></caption>
			<thead><tr>
	<th>Format</th>
	<th>Function</th>
<th>Returns</th>
			</tr></thead><tfoot><tr style="background-color:#ffe"><td></td><td colspan="2"><sup>1</sup> May be modified by appending &ldquo;_&rdquo; to the directive.</td></tr></tfoot>
			<tr class="firstRow">
				<td>A</td>
				<td>String with trailing nulls and spaces removed.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>a</td>
				<td>String.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>B</td>
				<td>Extract bits from each character (msb first).</td>
				<td>String</td>
			</tr>
			<tr>
				<td>b</td>
				<td>Extract bits from each character (lsb first).</td>
				<td>String</td>
			</tr>
			<tr>
				<td>C</td>
				<td>Extract a character as an unsigned integer.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>c</td>
				<td>Extract a character as an integer.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>d</td>
				<td>Treat <em>sizeof(double)</em> characters as a native double.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>E</td>
				<td>Treat <em>sizeof(double)</em> characters as a double in little-endian byte order.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>e</td>
				<td>Treat <em>sizeof(float)</em> characters as a float in little-endian byte order.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>f</td>
				<td>Treat <em>sizeof(float)</em> characters as a native float.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>G</td>
				<td>Treat <em>sizeof(double)</em> characters as a double in network byte order.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>g</td>
				<td>Treat <em>sizeof(float)</em> characters as a float in network byte order.</td>
				<td>Float</td>
			</tr>
			<tr>
				<td>H</td>
				<td>Extract hex nibbles from each character (most significant first).</td>
				<td>String</td>
			</tr>
			<tr>
				<td>h</td>
				<td>Extract hex nibbles from each character (least significant first).</td>
				<td>String</td>
			</tr>
			<tr>
				<td>I</td>
				<td>Treat <em>sizeof(int)</em><sup>1</sup> successive characters as an unsigned native integer.</td>
				<td>Integer</td>
			</tr>
			<tr>
				<td>i</td>
				<td>Treat <em>sizeof(int)</em><sup>1</sup> successive characters as a signed native integer.</td>
				<td>Integer</td>
			</tr>
			<tr>
				<td>L</td>
				<td>Treat four<sup>1</sup> successive characters as an unsigned native
				  long integer.</td>
				<td>Integer</td>
			</tr>
			<tr>
				<td>l</td>
				<td>Treat four<sup>1</sup> successive characters as a signed native
				  long integer.</td>
				<td>Integer</td>
			</tr>
			<tr>
				<td>M</td>
				<td>Extract a quoted-printable string.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>m</td>
				<td>Extract a base64 encoded string.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>N</td>
				<td>Treat four characters as an unsigned long in network byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>n</td>
				<td>Treat two characters as an unsigned short in network byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>P</td>
				<td>Treat <em>sizeof(char *)</em> characters as a pointer, and  return <em>len</em> characters from the referenced location.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>p</td>
				<td>Treat <em>sizeof(char *)</em> characters as a pointer to a  null-terminated string.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>S</td>
				<td>Treat two<sup>1</sup> successive characters as an unsigned short in
				  native byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>s</td>
				<td>Treat two<sup>1</sup> successive characters as a signed short in
				  native byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>U</td>
				<td>Extract UTF-8 characters as unsigned integers.</td>
				<td>Integer</td>
			</tr>
			<tr>
				<td>u</td>
				<td>Extract a UU-encoded string.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>V</td>
				<td>Treat four characters as an unsigned long in little-endian byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>v</td>
				<td>Treat two characters as an unsigned short in little-endian byte order.</td>
				<td>Fixnum</td>
			</tr>
			<tr>
				<td>X</td>
				<td>Skip backward one character.</td>
				<td>&mdash;</td>
			</tr>
			<tr>
				<td>x</td>
				<td>Skip forward one character.</td>
				<td>&mdash;</td>
			</tr>
			<tr>
				<td>Z</td>
				<td>String with trailing nulls removed.</td>
				<td>String</td>
			</tr>
			<tr>
				<td>@</td>
				<td>Skip to the offset given by the length argument.</td>
				<td>&mdash;</td>
			</tr>
		</table>

<div><code class="block">"abc \0\0abc \0\0".unpack('A6Z6') <span class="output"><span class="outputmark">&rarr;</span> ["abc", "abc "]</span>
"abc \0\0".unpack('a3a3') <span class="output"><span class="outputmark">&rarr;</span> ["abc", " \000\000"]</span>
"aa".unpack('b8B8') <span class="output"><span class="outputmark">&rarr;</span> ["10000110", "01100001"]</span>
"aaa".unpack('h2H2c') <span class="output"><span class="outputmark">&rarr;</span> ["16", "61", 97]</span>
"\xfe\xff\xfe\xff".unpack('sS') <span class="output"><span class="outputmark">&rarr;</span> [-2, 65534]</span>
"now=20is".unpack('M*') <span class="output"><span class="outputmark">&rarr;</span> ["now is"]</span>
"whole".unpack('xax2aX2aX1aX2a') <span class="output"><span class="outputmark">&rarr;</span> ["h", "e", "l", "l", "o"]</span></code></div>

		</dd>

	<dt id="String.upcase">upcase</dt>
		<dd class="callseq"><i class="obj">str</i>.upcase  &rarr; <i class="obj">aString</i></dd>
		<dd class="desc">Returns a copy of <i class="obj">str</i> with all lowercase letters replaced
      with their uppercase counterparts. The operation is locale
      insensitive&mdash;only characters &ldquo;a&rdquo; to &ldquo;z&rdquo; are affected.

<div><code class="block">"hEllO".upcase <span class="output"><span class="outputmark">&rarr;</span> "HELLO"</span></code></div>

		</dd>

	<dt id="String.upcase_oh">upcase!</dt>
		<dd class="callseq"><i class="obj">str</i>.upcase!  &rarr; <i class="obj">str</i> or <code>nil</code></dd>
		<dd class="desc">Upcases the contents of <i class="obj">str</i>, returning <code class="const">nil</code> if no changes were made.</dd>

	<dt id="String.upto">upto</dt>
		<dd class="callseq"><i class="obj">str</i>.upto( <i class="obj">aString</i> ) {| s | block } &rarr; <i class="obj">str</i></dd>
		<dd class="desc">Iterates through successive values, starting at <i class="obj">str</i> and ending at <i class="obj">aString</i> inclusive, passing each value in turn to the block. The <code class="class_instance_method"><a href="ref_c_string.html#String.succ"><span class="class">String</span>#<span class="method">succ</span></a></code> method is used to generate each value.

<div><code class="block">"a8".upto("b6") {|s| print s, ' ' }
for s in "a8".."b6"
  print s, ' '
end</code></div>
<p class="produces"><em>produces:</em></p>
<div><code class="block">a8 a9 b0 b1 b2 b3 b4 b5 b6
a8 a9 b0 b1 b2 b3 b4 b5 b6</code></div></dd>
</dl>

<div id="menubot" class="menu">
	
	<a href="frameset.html" class="contents" target="_top">^Contents^</a>
</div>

<div id="copyright">
	<p>Extracted from the book "Programming Ruby -  The Pragmatic Programmer's Guide"</p>
	<p>Copyright &copy; 2001 by Addison Wesley Longman, Inc. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at <a href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>).</p>
	<p>Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder.</p>
	<p>Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.</p>
</div>

<a href="ref_c_string.html" target="_top" id="expand" title="Show this content in its own window" onclick="this.href=window.location.href"><img src="includes/expand.png" alt="Show this content in its own window" width="15" height="15"></a>
<script type="text/javascript">
	if (top==self && document.getElementById){
		ex = document.getElementById('expand');
		img = ex.getElementsByTagName('img')[0];
		ex.title=img.alt="Show this content alongside the Table of Contents";
		ex.onclick=function(){ return true }
		ex.href="frameset.html?content="+escape(self.location.href);
		img.src="includes/collapse.png";
	}
</script>
</body>
</html>
